This file is a merged representation of the entire codebase, combined into a single document.
Generated by Repomix on: 2025-02-11T10:32:10.015Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
functions/
  24so-approval-flow/
    index.ts
    package.json
  24so-create-order/
    index.ts
    package.json
  create-chat-group/
    index.ts
    package.json
  create-event/
    index.ts
    package.json
  create-membership-from-shop/
    index.ts
    package.json
  create-post/
    index.ts
    package.json
  create-user-doc/
    index.ts
    package.json
  election-vote/
    index.ts
    package.json
  extract-pdf/
    index.ts
    package.json
  get-instagram-posts-by-hashtag/
    index.ts
    package.json
  verify-biso-membership/
    index.ts
    package.json
  vipps-callback/
    index.ts
    package.json
  vipps-payment/
    index.ts
    package.json
  webshop-product/
    index.ts
    package.json
packages/
  appwrite/
    src/
      castVote.ts
      chatGroup.ts
      index.ts
    .gitignore
    index.ts
    package.json
    README.md
    tsconfig.json
  instagram/
    index.ts
    package.json
    README.md
  twentyfour/
    src/
      accountService.ts
      attachmentService.ts
      soapClient.ts
      types.ts
    .gitignore
    index.ts
    package.json
    README.md
    tsconfig.json
  types/
    index.ts
    package.json
  utils/
    extract-text-from-pdf.ts
    package.json
  vipps/
    src/
      index.ts
    index.ts
    package.json
.gitattributes
.gitignore
package.json
README.md
tsconfig.json

================================================================
Files
================================================================

================
File: functions/24so-approval-flow/index.ts
================
import { accountService, attachmentService, FileType, FileLocation, soapClient, UserDefinedDimensionKey } from "@biso/twentyfour";
import { Context } from "@biso/types";
import { createAdminClient } from "@biso/appwrite";
import { Models } from "node-appwrite";
import sharp from 'sharp';

// Constants
const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
const ALLOWED_MIME_TYPES = [
    'image/jpeg',
    'image/png',
    'image/gif',
    'image/bmp',
    'image/tiff'
];

// 24SevenOffice Dimension Types
enum DimensionType {
    None = 'None',
    Department = 'Department',
    Employee = 'Employee',
    Project = 'Project',
    Product = 'Product',
    Customer = 'Customer',
    CustomerOrderSlip = 'CustomerOrderSlip',
    SupplierOrderSlip = 'SupplierOrderSlip',
    UserDefined = 'UserDefined'
}

interface KeyValuePair {
    Key: string;
    Value: string;
}

interface UserDefinedDimensions {
    Type: UserDefinedDimensionKey;
    Name: string;
    Value: string;
    TypeId: string;
}

interface Dimension {
    Type: DimensionType;
    Name: string;
    Value: string;
    Percent?: number;
    TypeId?: number;  // For UserDefinedDimensions (TypeId >= 100)
}

// Custom error classes
class FileProcessingError extends Error {
    constructor(message: string, public readonly cause?: Error) {
        super(message);
        this.name = 'FileProcessingError';
    }
}

class ValidationError extends Error {
    constructor(message: string) {
        super(message);
        this.name = 'ValidationError';
    }
}

interface User extends Models.Document {
    phone: string;
    address: string;
    city: string;
    zip: string;
    bank_account: string;
    name: string;
    email: string;
    campus_id: string;
    department_ids: string[];
    student_id: string;
    swift: string;
    isActive: boolean;
}

interface ExpenseAttachment extends Models.Document {
    date: string;
    url: string;
    amount: number;
    description: string;
    type: string;
}

interface Expense extends Models.Document {
    campus: string;
    department: string;
    bank_account: string;
    description: string;
    total: number;
    prepayment_amount: number;
    status: 'pending' | 'approved' | 'rejected';
    invoice_id: number | null;
    userId: string;
    user?: User;  // From relationship
    expenseAttachments?: ExpenseAttachment[];  // From relationship
    stampNo?: number;  // Added for 24SO integration
}

function validateFile(buffer: Buffer, mimeType: string): void {
    if (buffer.length > MAX_FILE_SIZE) {
        throw new ValidationError(`File size exceeds maximum allowed size of ${MAX_FILE_SIZE / 1024 / 1024}MB`);
    }
    
    if (mimeType === 'application/pdf') {
        throw new ValidationError(
            'PDF files are not supported by 24SevenOffice. Please convert the PDF to an image format (PNG, JPEG, etc.) before uploading.'
        );
    }
    
    if (!ALLOWED_MIME_TYPES.includes(mimeType)) {
        throw new ValidationError(`Unsupported file type: ${mimeType}. Allowed types are: ${ALLOWED_MIME_TYPES.join(', ')}`);
    }
}

function getFileType(mimeType: string): FileType {
    switch (mimeType) {
        case 'image/jpeg': return FileType.JPEG;
        case 'image/png': return FileType.PNG;
        case 'image/gif': return FileType.GIF;
        case 'image/bmp': return FileType.BMP;
        case 'image/tiff': return FileType.TIFF;
        default: return FileType.PNG;
    }
}

async function convertPdfToImage(pdfBuffer: Buffer, log: (msg: any) => void): Promise<Buffer> {
    const startTime = Date.now();
    log(`Starting PDF conversion. File size: ${pdfBuffer.length / 1024}KB`);

    try {
        // Convert PDF to PNG using sharp
        const image = await sharp(pdfBuffer, { page: 0 })  // Get first page
            .png()
            .resize(2000, null, {  // Resize to 2000px width, maintain aspect ratio
                withoutEnlargement: true,
                fit: 'inside'
            })
            .toBuffer();

        // Log conversion metrics
        const endTime = Date.now();
        log(`PDF conversion completed. Duration: ${endTime - startTime}ms, Output size: ${image.length / 1024}KB`);
        
        return image;
    } catch (err) {
        throw new FileProcessingError('Failed to convert PDF to image', err instanceof Error ? err : undefined);
    }
}

async function processFileForUpload(
    fileBuffer: Buffer,
    mimeType: string,
    log: (msg: any) => void
): Promise<{ buffer: Buffer; fileType: FileType }> {
    if (fileBuffer.length > MAX_FILE_SIZE) {
        throw new ValidationError(`File size exceeds maximum allowed size of ${MAX_FILE_SIZE / 1024 / 1024}MB`);
    }
    
    log(`Processing file of type ${mimeType}, size: ${fileBuffer.length / 1024}KB`);
    
    // Handle PDF conversion
    if (mimeType === 'application/pdf') {
        log('Converting PDF to PNG...');
        const convertedBuffer = await convertPdfToImage(fileBuffer, log);
        return {
            buffer: convertedBuffer,
            fileType: FileType.PNG
        };
    }
    
    // Validate other file types
    if (!ALLOWED_MIME_TYPES.includes(mimeType)) {
        throw new ValidationError(`Unsupported file type: ${mimeType}. Allowed types are: ${ALLOWED_MIME_TYPES.join(', ')}`);
    }
    
    return {
        buffer: fileBuffer,
        fileType: getFileType(mimeType)
    };
}

function formatDimensions(dimensions: UserDefinedDimensions[]): KeyValuePair[] {
    return dimensions.map((dim, index) => ({
        Key: `Dimension${index + 1}`,
        Value: `${dim.Type}=${dim.Value}`
    }));
}

export default async ({ req, res, log, error }: Context) => {
    const { uploadAttachment } = attachmentService(error, log);
    const { databases, storage } = await createAdminClient();
    const { getAccessToken, searchCustomer, createCustomer } = soapClient(error, log);

    try {
        const expenseId = req.body.$id;
        if (!expenseId) {
            throw new ValidationError('Expense ID is required');
        }

        // Get expense details from database with relationships expanded
        const expense = await databases.getDocument<Expense>(
            'main',
            'expenses',
            expenseId,
            [
                'user',
                'expenseAttachments'
            ]
        );

        if (!expense.invoice_id) {
            throw new ValidationError('Invoice not yet generated');
        }

        if (!expense.user || !expense.expenseAttachments) {
            throw new ValidationError('Required relationships not loaded');
        }

        // Get authentication token
        const authResult = await getAccessToken();
        if (authResult.status !== 'ok' || !authResult.accessToken) {
            throw new Error('Failed to authenticate with 24SevenOffice');
        }
        const token = authResult.accessToken;

        // First, upload the invoice
        log('Uploading invoice...');

        let customerId = null;
        const existingCustomer = await searchCustomer(token, expense.user.name, expense.user.email);
        if (!existingCustomer) {
            const newCustomer = await createCustomer(token, { name: expense.user.name, email: expense.user.email });
            customerId = newCustomer.Id;
        } else {
            customerId = existingCustomer.Id;
        }

        const invoiceFileId = `invoice_${expense.invoice_id}`;
        const invoiceFile = await storage.getFileDownload('expense_invoices', invoiceFileId);
        const invoiceFileMeta = await storage.getFile('expense_invoices', invoiceFileId);
        
        // Convert if PDF
        const { buffer: invoiceBuffer, fileType: invoiceFileType } = await processFileForUpload(
            Buffer.from(invoiceFile),
            invoiceFileMeta.mimeType,
            log
        );
        
        // Prepare dimensions
        const dimensions: UserDefinedDimensions[] = [
            {
                Type: UserDefinedDimensionKey.Department,
                Name: 'Department',
                Value: expense.department,
                TypeId: '1'  // You might need to adjust this ID based on your 24SO configuration
            },
            {
                Type: UserDefinedDimensionKey.UserDefined,
                Name: 'Campus',
                Value: expense.campus,
                TypeId: '100'  // Using 100 as it's the start of user-defined dimension IDs
            }
        ];

        const dimensionMetadata = formatDimensions(dimensions);
        
        const invoiceStampNo = await uploadAttachment(token, {
            fileType: invoiceFileType,
            fileBuffer: invoiceBuffer,
            customMetadata: [
                { Key: 'InvoiceNo', Value: expense.invoice_id.toString() },
                { Key: 'CustomerNo', Value: customerId },
                { Key: 'InvoiceOCR', Value: expense.invoice_id.toString() },
                { Key: 'Amount', Value: expense.total.toString() },
                { Key: 'Credit', Value: '7610' },
                { Key: 'Debit', Value: '2400' },
                { Key: 'InvoiceDate', Value: expense.created_at },
                { Key: 'BankAccountNo', Value: expense.bank_account },
                ...dimensionMetadata
            ]
        });

        log(`Invoice uploaded with stamp number: ${invoiceStampNo}`);

        // Track failed receipts
        const failedReceipts: Array<{ id: string; error: string }> = [];

        // Then upload all receipts with the same stamp number
        for (let i = 0; i < expense.expenseAttachments.length; i++) {
            const attachment = expense.expenseAttachments[i];
            log(`Uploading receipt ${i + 1}/${expense.expenseAttachments.length}...`);

            try {
                // Get file ID from the URL
                const fileId = attachment.url.split('/').pop() as string;
                const receiptFile = await storage.getFileDownload('expense_attachments', fileId);
                const fileMeta = await storage.getFile('expense_attachments', fileId);

                // Convert if PDF
                const { buffer: receiptBuffer, fileType: receiptFileType } = await processFileForUpload(
                    Buffer.from(receiptFile),
                    fileMeta.mimeType,
                    log
                );

                await uploadAttachment(token, {
                    fileType: receiptFileType,
                    fileBuffer: receiptBuffer,
                    pageNo: i + 1,
                    customMetadata: [
                        { Key: 'Amount', Value: attachment.amount.toString() },
                        { Key: 'Comment', Value: attachment.description },
                        { Key: 'InvoiceDate', Value: attachment.date },
                        { Key: 'Type', Value: attachment.type },
                        ...dimensionMetadata
                    ]
                });

                log(`Receipt ${i + 1} uploaded successfully`);
            } catch (uploadErr) {
                const errorMessage = uploadErr instanceof Error ? uploadErr.message : 'Unknown error';
                error(`Failed to upload receipt ${i + 1}: ${errorMessage}`);
                failedReceipts.push({ 
                    id: attachment.$id,
                    error: errorMessage
                });
                continue;
            }
        }

        // Update expense status in database
        await databases.updateDocument(
            'main',
            'expenses',
            expenseId,
            {
                status: 'approved',
                stampNo: invoiceStampNo
            }
        );

        return res.json({
            success: true,
            stampNo: invoiceStampNo,
            message: `Successfully uploaded invoice and ${expense.expenseAttachments.length - failedReceipts.length} receipts`,
            failedReceipts: failedReceipts.length > 0 ? failedReceipts : undefined
        });

    } catch (err) {
        error('Error processing expense:');
        error(err);
        
        const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';
        const statusCode = err instanceof ValidationError ? 400 : 500;
        
        return res.json({
            success: false,
            error: errorMessage
        }, statusCode);
    }
};

================
File: functions/24so-approval-flow/package.json
================
{
  "name": "@biso/24so-approval-flow",
  "version": "0.0.1",
  "module": "index.ts",
  "type": "module",
  "dependencies": {
    "@biso/appwrite": "0.0.1",
    "@biso/twentyfour": "0.0.1",
    "@biso/types": "0.0.1",
    "bun-types": "latest",
    "pdf-lib": "^1.17.1",
    "pdf2pic": "^3.1.3",
    "sharp": "^0.33.5",
    "zod": "1"
  }
}

================
File: functions/24so-create-order/index.ts
================
import { Models } from "@biso/appwrite";
import { Customer, soapClient, UserDefinedDimensionKey } from "@biso/twentyfour";

type Context = {
    req: any;
    res: any;
    log: (msg: any) => void;
    error: (msg: any) => void;
};

interface RequestBody {
    reference: string;
    amount: number;
    description: string;
    membership_id: string;
    membership?: string;
    status: string;
    paid_amount: number;
    user?: Models.Document;
    payment_method: string;
    user_id: string;
    $id: string;
}

const SHOULD_INVOICE = process.env.SHOULD_INVOICE!;
const SHOULD_CREATE_CUSTOMER = process.env.SHOULD_CREATE_CUSTOMER!;

export default async ({ req, res, log, error }: Context) => {
    try {
        log('Parsing request body...');
        log('Request body: ' + JSON.stringify(req.body));

        const body = req.body as RequestBody;
        const { reference, amount, description, membership_id, status, paid_amount, user, payment_method, user_id, $id, membership } = body;

        if (!reference || !amount || !description || !membership_id || !status || !paid_amount || !user || !payment_method || !user_id) {
            log('Missing required parameters');
            return res.json({ error: 'Missing required parameters' });
        }

        if (status !== 'SUCCESS') {
            log('Payment status is not SUCCESS, returning early');
            return res.json({ error: 'Payment status is not SUCCESS' });
        }

        let existingCustomer: Customer | null = null;
        const { createInvoice, getAccessToken, updateCustomerCategory, getCustomer, createCustomer, getCustomerByExternalId } = soapClient(log, error);

        log('Attempting to retrieve access token...');
        const { accessToken, status: tokenStatus } = await getAccessToken();
        if (tokenStatus !== 'ok') {
            log('Failed to retrieve access token');
            return res.json({ error: 'Failed to retrieve access token' });
        }
        log('Token response: ' + JSON.stringify(accessToken));

        const studentId = parseInt(user.student_id.replace('s', ''), 10);

        if (isNaN(studentId)) {
            error('Invalid student number format');
            return res.json({ error: 'Invalid student number format' });
        }

        let response;
        try {
            log(`Attempting to retrieve customer with studentId: ${studentId}`);
            response = await getCustomer(accessToken, studentId);
            log('Response: ' + JSON.stringify(response));
        } catch (err) {
            error(`Error during customer retrieval on CompanyId, trying with ExternalId: ${err}`);
            try {
                log(`Attempting to retrieve customer with ExternalId: ${studentId}`);
                response = await getCustomerByExternalId(accessToken, studentId);
                log('Response: ' + JSON.stringify(response));
            } catch (err) {
                error(`Error during customer retrieval on ExternalId: ${err}`);
                // Send a status update for failure
                const membershipType = description;
                const campusName = user.campus.name;
                const status = "Mottatt";
                log('Sending status update to Sharepoint due to customer retrieval failure...');
                await sendStatusUpdateToSharepoint(studentId, `${user.name}`, membershipType.toString(), status, campusName, log, error);
                return res.json({ error: 'Failed to retrieve customer' });
            }
        }

        if (response) {
            existingCustomer = response as Customer;
            log(`Existing customer found for studentId: ${studentId} - ${JSON.stringify(existingCustomer)}`);
        } else if (SHOULD_CREATE_CUSTOMER === 'true') {
            log(`Customer not found for studentId: ${studentId}, creating new customer...`);
            const customerResponse = await createCustomer(accessToken, {
                Name: user.name,
                studentId: studentId.toString(),
                firstName: user.firstName
            });

            if (!customerResponse) {
                log('Failed to create customer');
                return res.json({ error: 'Failed to create customer' });
            }

            existingCustomer = await customerResponse.json() as Customer;
            log(`New customer created with ID: ${existingCustomer.Id} for studentId: ${studentId}`);
        }

        if (!existingCustomer) {
            log(`Customer not found for studentId: ${studentId}, and customer creation is disabled. Exiting early...`);
            const membershipType = description;
            const campusName = user.campus.name;
            const status = "Mottatt";
            log('Sending status update to Sharepoint because customer creation is disabled...');
            await sendStatusUpdateToSharepoint(studentId, `${user.name}`, membershipType.toString(), status, campusName, log, error);
            return res.json({ error: 'Customer not found and creation is disabled' });
        }

        log('Customer found or created successfully, proceeding to update customer category...');
        const departmentId = determineDepartmentId(user.campus.$id);
        const accrualDate = determineAccrualDate();

        let membershipObj: any;
        if (typeof membership === 'string') {
            try {
                membershipObj = JSON.parse(membership);
            } catch (parseError) {
                log('Failed to parse membership string');
                return res.json({ error: 'Invalid membership format' });
            }
        } else {
            membershipObj = membership;
        }

        if (!membershipObj.category || !membershipObj.name) {
            log('Membership object is missing required properties');
            return res.json({ error: 'Invalid membership object' });
        }

        try {
            log('Attempting to update customer category...');
            await updateCustomerCategory(accessToken, membershipObj.category, studentId);
            log('Customer category updated successfully');
        } catch (err) {
            error('Error updating customer category: ' + err);
            return res.json({ error: 'Failed to update customer category' });
        }

        const invoiceStatus = SHOULD_INVOICE === 'true' ? 'Invoiced' : 'Draft';
        const accrualLength = determineAccrualLength(description);

        let invoiceResponse;
        try {
            log(`Attempting to create invoice for studentId: ${studentId}...`);
            invoiceResponse = await createInvoice(accessToken, {
                CustomerId: existingCustomer.Id,
                OrderStatus: invoiceStatus,
                DepartmentId: departmentId,
                IncludeVAT: true,
                PaymentAmount: paid_amount,
                PaymentMethodId: 1,
                PaymentTime: 0,
                UserDefinedDimensions: [
                    {
                        Type: UserDefinedDimensionKey.UserDefined,
                        Name: user.campus.name,
                        Value: user.campus_id,
                        TypeId: '101',
                    },
                    {
                        Type: UserDefinedDimensionKey.UserDefined,
                        Name: membershipObj.name,
                        Value: membershipObj.name,
                        TypeId: '102',
                    },
                ],
                InvoiceRows: [
                    {
                        ProductId: parseInt(membership_id),
                        Price: paid_amount,
                        Quantity: 1,
                    },
                ],
                AccrualDate: accrualDate,
                AccrualLength: accrualLength,
            });
            log('Invoice created successfully: ' + JSON.stringify(invoiceResponse));
        } catch (err) {
            error('Error creating invoice: ' + err);
            const name = existingCustomer.Name;
            const membershipType = description;
            const campusName = user.campus.name;
            const status = "Faktura feilet";
            log('Sending status update to Sharepoint for failed process...');
            await sendStatusUpdateToSharepoint(studentId, name, membershipType.toString(), status, campusName, log, error);
            log('Status update sent successfully');
            return res.json({ error: 'Failed to create invoice' });
        }

        if (invoiceResponse && existingCustomer && membershipObj) {
            const name = existingCustomer.Name;
            const membershipType = description;
            const campusName = user.campus.name;
            const status = SHOULD_INVOICE === "true" ? "Ferdig" : "Faktura opprettet";

            log('Sending status update to Sharepoint for completed process...');
            await sendStatusUpdateToSharepoint(studentId, name, membershipType.toString(), status, campusName, log, error);
            log('Status update sent successfully');
        }

        return res.json({ success: 'Process completed successfully' });
    } catch (err) {
        error(`Unexpected error: ${err instanceof Error ? err.message : 'Unknown error'}`);
        return res.json({ error: 'An unexpected error occurred' });
    }
};


// Utility function to determine department ID based on campus ID
function determineDepartmentId(campusId: string): number {
    switch (campusId) {
        case '1':
            return 1;
        case '2':
            return 300;
        case '3':
            return 600;
        case '4':
            return 800;
        default:
            return 1000; // Default to National
    }
}


function determineAccrualDate(): string {
    const currentDate = new Date();
    let accrualDate: Date;

    // Determine the accrual date based on the purchase time of the year
    if (currentDate.getMonth() >= 6) { // July or later (July is month 6)
        accrualDate = new Date(currentDate.getFullYear(), 6, 1); // July 1st of the current year
    } else { // January through June
        accrualDate = new Date(currentDate.getFullYear(), 5, 1); // June 1st of the current year
    }

    const yyyy = accrualDate.getFullYear();
    const mm = String(accrualDate.getMonth() + 1).padStart(2, '0'); // Months are zero-based, so add 1
    const dd = String(accrualDate.getDate()).padStart(2, '0');

    return `${yyyy}-${mm}-${dd}`;
}

// Utility function to determine accrual length based on membership type
function determineAccrualLength(membershipType: string): number {
    switch (membershipType.toLowerCase()) {
        case 'semester':
            return 6; // 6 months
        case 'year':
            return 12; // 12 months
        case '3 years':
            return 36; // 36 months
        default:
            throw new Error('Invalid membership type');
    }
}

async function sendStatusUpdateToSharepoint(studentId: number, name: string, membershipType: string, status: string, campusName: string, log: (msg: any) => void, error: (msg: any) => void) {
    try {
        const body = {
            studentId,
            name,
            membershipType,
            status,
            campusName,
        };
        log(`Sending status update to Sharepoint: ${JSON.stringify(body)}`);
        const response = await fetch(`https://prod-62.westeurope.logic.azure.com:443/workflows/0292362fa91b46ef9d59267886f6a3a4/triggers/manual/paths/invoke?api-version=2016-06-01&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=J3pmj_cNjprnZeK9KJop0UjD9lcPms_L6Olz4OTDch4`, {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify(body),
        });

        const data = await response.json();
        log(`Status update sent successfully: ${JSON.stringify(data)}`);
    } catch (err) {
        if (err instanceof Error) {
            error(`Failed to send status update: ${err.message}`);
        } else {
            error('Failed to send status update: An unknown error occurred');
        }
    }
}

================
File: functions/24so-create-order/package.json
================
{
  "name": "@biso/24so-create-order",
  "version": "0.0.1",
  "module": "index.ts",
  "type": "module",
  "dependencies": {
    "bun-types": "latest",
    "zod": "1",
    "@biso/appwrite": "0.0.1",
    "@biso/twentyfour": "0.0.1"
  }
}

================
File: functions/create-chat-group/index.ts
================
import { createTeam, Models } from '@biso/appwrite';

type Context = {
    req: any;
    res: any;
    log: (msg: any) => void;
    error: (msg: any) => void;
};

export default async ({ req, res, log, error }: Context) => {
    try {


        log('Parsing request body...');
        const body = JSON.parse(req.body);
        const teamName = body.name as string;
        const users = body.users as Models.Document[] | undefined;
        const emails = body.emails as string[] | undefined;

        if (!users && !emails) {
            log('No users or emails provided.');
            return res.json({ error: 'No users or emails provided' });
        }

        log('Creating team...');
        const teamId = await createTeam({
            jwt: req.headers['x-appwrite-user-jwt']!,
            teamName,
            users,
            emails,
            log
        });

        if (teamId) {
            log('Returning team ID...');
            return res.json({ teamId });
        } else {
            log('No team ID returned.');
            return res.json({ error: 'No team ID returned' });
        }
    } catch (err: any) {
        log('An error occurred: ' + err);
        return res.json({ error: (err as Error).message });
    }
};

================
File: functions/create-chat-group/package.json
================
{
  "name": "@biso/create-chat-group",
  "version": "0.0.1",
  "module": "index.ts",
  "type": "module",
  "dependencies": {
    "bun-types": "latest",
    "zod": "1",
    "@biso/appwrite": "0.0.1"
  }
}

================
File: functions/create-event/index.ts
================
import { createAdminClient } from "@biso/appwrite";

interface Event {
    event: string;
    data: {
        event: {
        id: number;
        date: string;
        slug: string;
        status: string;
        link: string;
        title: {
            rendered: string;
        };
        content: {
            rendered: string;
        };
        };
        organizer_name: string;
    }
}

interface Context {
    req: any;
    res: any;
    log: (msg: any) => void;
    error: (msg: any) => void;
};

function getCampusIdFromOrganizerSlug(slug: string) {
    const campusMapping = {
        'biso-oslo': '1',
        'biso-bergen': '2',
        'biso-trondheim': '3',
        'biso-stavanger': '4',
        'biso-national': '5'
    } as const;
    
    // Return the corresponding campus ID or undefined if the slug doesn't match
    return campusMapping[slug as keyof typeof campusMapping];
}

export default async ({ req, res, log, error }: Context) => {
    log('Request received with method: ' + req.method + ' and body: ' + JSON.stringify(req.body));

    if (req.method === 'GET') {
        log('GET method not allowed');
        return res.json({ message: 'Not allowed.' });
    }

    const { 
        event,
        data: {
            event: {
                id,
                date,
                slug,
                status,
                link,
                title,
                content
            },
            organizer_name
        }
    } = req.body as Event;
    


    log(`Processing event: ${event} for organizer: ${organizer_name} with ID: ${id}`);

    const client = createAdminClient();

    if (event === 'event_created') {
        log('Starting event creation process');

        try {
            const eventResponse = await (await client).databases.createDocument('app', 'event', id.toString(), {
                title: title.rendered,
                description: content.rendered,
                event_date: date,
                campus_id: getCampusIdFromOrganizerSlug(organizer_name),
                campus: getCampusIdFromOrganizerSlug(organizer_name),
                url: link,
                slug,
                status
            });
            log('Event created successfully with response: ' + JSON.stringify(eventResponse));
            return res.json({ message: 'Event created successfully' });
        } catch (err) {
            error('Event creation failed: ' + (err instanceof Error ? err.message : JSON.stringify(err)));
            return res.json({ message: 'Event creation failed', error: err });
        }
    }

    if (event === 'event_updated') {
        log('Starting event update process');

        try {
            const eventResponse = await (await client).databases.updateDocument('app', 'events', id.toString(), {
                title: title.rendered,
                description: content.rendered,
                event_date: date,
                campus_id: getCampusIdFromOrganizerSlug(organizer_name),
                campus: getCampusIdFromOrganizerSlug(organizer_name),
                url: link,
                slug,
                status
            });
            log('Event updated successfully with response: ' + JSON.stringify(eventResponse));
            return res.json({ message: 'Event updated successfully' });
        } catch (err) {
            error('Event update failed: ' + (err instanceof Error ? err.message : JSON.stringify(err)));
            return res.json({ message: 'Event update failed', error: err });
        }
    }

    log('Event not found or unsupported event type: ' + event);
    return res.json({ message: 'Event not found' });
}

================
File: functions/create-event/package.json
================
{
  "name": "@biso/create-event",
  "version": "0.0.1",
  "module": "index.ts",
  "type": "module",
  "dependencies": {
    "bun-types": "latest",
    "zod": "1",
    "@biso/appwrite": "0.0.1"
  }
}

================
File: functions/create-membership-from-shop/index.ts
================
import { Models } from "@biso/appwrite";
import { Customer, soapClient, UserDefinedDimensionKey } from "@biso/twentyfour";

type Context = {
    req: any;
    res: any;
    log: (msg: any) => void;
    error: (msg: any) => void;
};

interface RequestBody {
    customer: any;
    snumber: string;
    selected_variation: string;
    price: string;
}

const SHOULD_INVOICE = process.env.SHOULD_INVOICE!;
const SHOULD_CREATE_CUSTOMER = process.env.SHOULD_CREATE_CUSTOMER!;

export default async ({ req, res, log, error }: Context) => {
    try {
        log('Parsing request body...');
        log('Request body: ' + JSON.stringify(req.body));

        const body = req.body as RequestBody;
        const { customer, snumber, selected_variation, price } = body;

        if (!customer || !snumber || !selected_variation) {
            error('Missing required parameters: customer, snumber, or selected_variation');
            return res.json({ error: 'Missing required parameters' });
        }

        const shouldCreateCustomer = SHOULD_CREATE_CUSTOMER === 'true';
        let existingCustomer: Customer | null = null;
        const { createInvoice, getAccessToken, updateCustomerCategory, getCustomer, createCustomer, getCustomerByExternalId } = soapClient(log, error);

        log('Attempting to retrieve access token...');
        const { accessToken, status: tokenStatus } = await getAccessToken();
        if (tokenStatus !== 'ok') {
            log('Failed to retrieve access token');
            return res.json({ error: 'Failed to retrieve access token' });
        }
        log('Token response: ' + JSON.stringify(accessToken));

        const cleanedSnumber = snumber.replace(/[^0-9]/g, ''); // Remove all non-numeric characters
        const studentId = parseInt(cleanedSnumber, 10); // Convert the cleaned string to an integer
        
        if (isNaN(studentId)) {
            error('Invalid student number format');
            return res.json({ error: 'Invalid student number format' });
        }
        
        let response;
        try {
            log(`Attempting to retrieve customer with studentId: ${studentId}`);
            response = await getCustomer(accessToken, studentId);
            log('Response: ' + JSON.stringify(response));
        } catch (err) {
            error(`Error during customer retrieval on CompanyId, trying with ExternalId: ${err}`);
            try {
                log(`Attempting to retrieve customer with ExternalId: ${studentId}`);
                response = await getCustomerByExternalId(accessToken, studentId);
                log('Response: ' + JSON.stringify(response));
            } catch (err) {
                error(`Error during customer retrieval on ExternalId: ${err}`);
                const membershipType = campusMapping[selected_variation].type;
                const campusName = campusMapping[selected_variation].name;
                const status = "Mottatt";
                log('Sending status update to Sharepoint due to customer retrieval failure...');
                await sendStatusUpdateToSharepoint(studentId, `${customer.first_name} ${customer.last_name}`, membershipType.toString(), status, campusName, log, error);
                return res.json({ error: 'Failed to retrieve customer' });
            }
        }

        if (response) {
            existingCustomer = response as Customer;
            log(`Existing customer found for snumber: ${snumber} - ${JSON.stringify(existingCustomer)}`);
        } else if (shouldCreateCustomer) {
            log(`Customer not found for snumber: ${snumber}, creating new customer...`);
            const customerResponse = await createCustomer(accessToken, {
                Name: `${customer.first_name} ${customer.last_name}`,
                studentId: snumber,
                firstName: customer.first_name
            });

            if (!customerResponse) {
                log('Failed to create customer');
                return res.json({ error: 'Failed to create customer' });
            }

            existingCustomer = await customerResponse.json() as Customer;
            log(`New customer created with ID: ${existingCustomer.Id} for snumber: ${studentId}`);
        }

        if (!shouldCreateCustomer && !existingCustomer) {
            log(`Customer not found for snumber: ${snumber}, and SHOULD_CREATE_CUSTOMER is false. Exiting early...`);
            const membershipType = campusMapping[selected_variation].type;
            const campusName = campusMapping[selected_variation].name;
            const status = "Mottatt";
            log('Sending status update to Sharepoint because customer creation is disabled...');
            await sendStatusUpdateToSharepoint(studentId, `${customer.first_name} ${customer.last_name}`, membershipType.toString(), status, campusName, log, error);
            return res.json({ error: 'Customer not found and creation is disabled' });
        }

        log('Customer found or created successfully, proceeding to update customer category...');
        const campus = determineCampusId(selected_variation);
        const departmentId = determineDepartmentId(campus.campus_id);
        const accrualDate = determineAccrualDate();


        const membershipObj = {
            customerId: existingCustomer?.Id || studentId,
            membershipId: selected_variation,
            category: categoryMapping[selected_variation],
            name: campusMapping[selected_variation].type,
        };

        try {
            log('Attempting to update customer category...');
            await updateCustomerCategory(accessToken, membershipObj.category, studentId);
            log('Customer category updated successfully');
        } catch (err) {
            error('Error updating customer category: ' + err);
            return res.json({ error: 'Failed to update customer category' });
        }

        const invoiceStatus = SHOULD_INVOICE === 'true' ? 'Invoiced' : 'Draft';
        const accrualLength = determineAccrualLength(campusMapping[selected_variation].type);

        const userCampus = {
            campus: determineCampusId(selected_variation),
            name: campusMapping[selected_variation].name,
        };

        //Current date in format YYYY-MM-DD
        const currentDate = new Date().toISOString().split('T')[0];

        let invoiceResponse;
        if (existingCustomer && membershipObj) {
        try {
            const invoiceBody = {
                CustomerId: existingCustomer.Id,
                OrderStatus: invoiceStatus,
                DepartmentId: departmentId,
                IncludeVAT: true,
                PaymentAmount: parseFloat(price),
                DateInvoiced: currentDate,
                PaymentMethodId: 1,
                PaymentTime: 0,
                UserDefinedDimensions: [
                    {
                        Type: UserDefinedDimensionKey.UserDefined,
                        Name: userCampus.campus.name,
                        Value: userCampus.campus.campus_id,
                        TypeId: '101',
                    },
                    {
                        Type: UserDefinedDimensionKey.UserDefined,
                        Name: determineMembershipId(membershipObj.name),
                        Value: membershipObj.name,
                        TypeId: '102',
                    },
                ],
                InvoiceRows: [
                    {
                        ProductId: parseInt(variationToProductIdMapping[selected_variation]),
                        Price: parseFloat(price),
                        Quantity: 1,
                    },
                ],
                AccrualDate: accrualDate,
                AccrualLength: accrualLength,
            };

            log(`Attempting to create invoice for customerId: ${studentId}...`);
            log('Invoice body: ' + JSON.stringify(invoiceBody));
            invoiceResponse = await createInvoice(accessToken, invoiceBody);
            log('Invoice created successfully: ' + JSON.stringify(invoiceResponse));
        } catch (err) {
            error('Error creating invoice: ' + err);
            const name = existingCustomer.Name;
            const membershipType = campusMapping[selected_variation].type;
            const campusName = campusMapping[selected_variation].name;
            const status = "Faktura feilet";
            log('Sending status update to Sharepoint for failed process...');
            await sendStatusUpdateToSharepoint(studentId, name, membershipType.toString(), status, campusName, log, error);
            log('Status update sent successfully');
            return res.json({ error: 'Failed to create invoice' });
        }
        }

        if (invoiceResponse && existingCustomer && membershipObj) {
            const name = existingCustomer.Name;
            const membershipType = campusMapping[selected_variation].type;
            const campusName = campusMapping[selected_variation].name;
            const status = SHOULD_INVOICE === "true" ? "Ferdig" : "Faktura opprettet";

            log('Sending status update to Sharepoint for completed process...');
            await sendStatusUpdateToSharepoint(studentId, name, membershipType.toString(), status, campusName, log, error);
            log('Status update sent successfully');
        }

        return res.json({ success: 'Process completed successfully' });
    } catch (err) {
        error(`Unexpected error: ${err instanceof Error ? err.message : 'Unknown error'}`);
        return res.json({ error: 'An unexpected error occurred' });
    }
};


// Utility function to determine department ID based on campus ID
function determineDepartmentId(campusId: string): number {
    switch (campusId) {
        case '1':
            return 1;
        case '2':
            return 300;
        case '3':
            return 600;
        case '4':
            return 800;
        default:
            return 1000; // Default to National
    }
}

function determineAccrualDate(): string {
    const currentDate = new Date();
    let accrualDate: Date;

    // Determine the accrual date based on the purchase time of the year
    if (currentDate.getMonth() >= 6) { // July or later (July is month 6)
        accrualDate = new Date(currentDate.getFullYear(), 6, 1); // July 1st of the current year
    } else { // January through June
        accrualDate = new Date(currentDate.getFullYear(), 5, 1); // June 1st of the current year
    }

    const yyyy = accrualDate.getFullYear();
    const mm = String(accrualDate.getMonth() + 1).padStart(2, '0'); // Months are zero-based, so add 1
    const dd = String(accrualDate.getDate()).padStart(2, '0');

    return `${yyyy}-${mm}-${dd}`;
}







async function sendStatusUpdateToSharepoint(studentId: number, name: string, membershipType: string, status: string, campusName: string, log: (msg: any) => void, error: (msg: any) => void) {
    try {
        const body = {
            studentId,
            name,
            membershipType,
            status,
            campusName, // Including the campus name in the request body
        };
        log(`Sending status update to Sharepoint: ${JSON.stringify(body)}`);
        const response = await fetch(`https://prod-62.westeurope.logic.azure.com:443/workflows/0292362fa91b46ef9d59267886f6a3a4/triggers/manual/paths/invoke?api-version=2016-06-01&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=J3pmj_cNjprnZeK9KJop0UjD9lcPms_L6Olz4OTDch4`, {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify(body),
        });

        const data = await response.json();
        log(`Status update sent successfully: ${JSON.stringify(data)}`);
    } catch (err) {
        if (err instanceof Error) {
            error(`Failed to send status update: ${err.message}`);
        } else {
            error('Failed to send status update: An unknown error occurred');
        }
    }
}


const campusMapping: { [key: string]: { campus_id: string, name: string, type: string } } = {
    '36728': { campus_id: '1', name: 'Oslo', type: 'Semester' },
    '36732': { campus_id: '1', name: 'Oslo', type: 'Year' },
    '36736': { campus_id: '1', name: 'Oslo', type: '3 Years' },
    '36729': { campus_id: '2', name: 'Bergen', type: 'Semester' },
    '36733': { campus_id: '2', name: 'Bergen', type: 'Year' },
    '36737': { campus_id: '2', name: 'Bergen', type: '3 Years' },
    '36730': { campus_id: '3', name: 'Trondheim', type: 'Semester' },
    '36734': { campus_id: '3', name: 'Trondheim', type: 'Year' },
    '36738': { campus_id: '3', name: 'Trondheim', type: '3 Years' },
    '36731': { campus_id: '4', name: 'Stavanger', type: 'Semester' },
    '36735': { campus_id: '4', name: 'Stavanger', type: 'Year' },
    '36739': { campus_id: '4', name: 'Stavanger', type: '3 Years' },
};


// Utility function to determine accrual length based on membership type
function determineAccrualLength(membershipType: string): number {
    switch (membershipType.toLowerCase()) {
        case 'semester':
            return 6; // 6 months
        case 'year':
            return 12; // 12 months
        case '3 years':
            return 36; // 36 months
        default:
            throw new Error('Invalid membership type');
    }
}

function determineCampusId(selected_variation: string): { campus_id: string, name: string } {
    const campus = campusMapping[selected_variation];
    return { campus_id: campus.campus_id, name: campus.name };
}

const categoryMapping: { [key: string]: number } = {
    '36728': 113170, // Semester
    '36729': 113170,
    '36730': 113170,
    '36731': 113170,
    '36732': 113172, // 1 Year
    '36733': 113172,
    '36734': 113172,
    '36735': 113172,
    '36736': 113171, // 3 years
    '36737': 113171,
    '36738': 113171,
    '36739': 113171,
};

/*
    '22141': { campus_id: '1', name: 'Oslo', type: 'Semester' },
    '22145': { campus_id: '1', name: 'Oslo', type: 'Year' },
    '22149': { campus_id: '1', name: 'Oslo', type: '3 Years' },
    '22142': { campus_id: '2', name: 'Bergen', type: 'Semester' },
    '22146': { campus_id: '2', name: 'Bergen', type: 'Year' },
    '22150': { campus_id: '2', name: 'Bergen', type: '3 Years' },
    '22143': { campus_id: '3', name: 'Trondheim', type: 'Semester' },
    '22147': { campus_id: '3', name: 'Trondheim', type: 'Year' },
    '22151': { campus_id: '3', name: 'Trondheim', type: '3 Years' },
    '22144': { campus_id: '4', name: 'Stavanger', type: 'Semester' },
    '22148': { campus_id: '4', name: 'Stavanger', type: 'Year' },
    '22152': { campus_id: '4', name: 'Stavanger', type: '3 Years' },
    */

const variationToProductIdMapping: { [key: string]: string } = {
    '36728': '50', // Semester
    '36729': '50',
    '36730': '50',
    '36731': '50',
    '36732': '69', // 1 Year
    '36733': '69',
    '36734': '69',
    '36735': '69',
    '36736': '80', // 3 years
    '36737': '80',
    '36738': '80',
    '36739': '80',
};

function determineMembershipId(membershipType: string): string {
    switch (membershipType.toLowerCase()) {
        case 'semester':
            return '100';
        case 'year':
            return '200';
        case '3 years':
            return '300';
        default:
            throw new Error('Invalid membership type');
    }
}

================
File: functions/create-membership-from-shop/package.json
================
{
  "name": "@biso/24so-create-order-from-shop",
  "version": "0.0.1",
  "module": "index.ts",
  "type": "module",
  "dependencies": {
    "@biso/appwrite": "0.0.1",
    "@biso/twentyfour": "0.0.1",
    "bun-types": "latest",
    "zod": "1"
  }
}

================
File: functions/create-post/index.ts
================
import { createAdminClient } from "@biso/appwrite";

type Context = {
    req: any;
    res: any;
    log: (msg: any) => void;
    error: (msg: any) => void;
};

interface Post {
    id: number;
    date: string;
    link: string;
    slug: string;
    status: string;
    title: Content;
    content: Content;
    acf: Acf;
}

interface Content {
    rendered: string;
}

interface Acf {
    campus: {
        value: string;
        label: string;
    };
    department_oslo?: {
        value: string;
        label: string;
    };
    department_bergen?: {
        value: string;
        label: string;
    };
    department_stavanger?: {
        value: string;
        label: string;
    };
    department_trondheim?: {
        value: string;
        label: string;
    };
    department_national?: {
        value: string;
        label: string;
    }
}


export default async ({ req, res, log, error }: Context) => {

    const { id, date, link, slug, status, content, acf, title } = req.body.data as Post;
    log('Parsed post data: ' + JSON.stringify(req.body.data));

    //Path to image url: "yoast_head_json.schema.@graph[2].url"
    const imageUrl = req.body.data.yoast_head_json.schema["@graph"][2].url;

    const client = await createAdminClient();

    let department;
    switch (acf.campus.value) {
        case '1':
            department = acf.department_oslo?.value;
            break;
        case '2':
            department = acf.department_bergen?.value;
            break;
        case '4':
            department = acf.department_stavanger?.value;
            break;
        case '3':
            department = acf.department_trondheim?.value;
            break;
        case '5':
            department = acf.department_national?.value;
            break;
        default:
            department = null; // or handle the case when department is not available
    }

    if (req.method === 'PATCH') {
        const contentBody = content.rendered;
        const post = await client.databases.createDocument('app', 'news', id.toString(), {
            content: contentBody,
            title: title.rendered,
            slug,
            url: link,
            created_at: date,
            status,
            campus: acf.campus.value,
            campus_id: acf.campus.value,
            department: department,
            department_id: department,
            image: imageUrl
        });

        return res.json({ post });
    }

    if (req.method === 'POST') {
        res.json({ error: 'Not implemented' });
    }

    if (req.method === 'DELETE') {

        if (!id) {
            return res.json({ error: 'No ID provided' });
        }

        const post = await client.databases.deleteDocument('app', 'news', id.toString());
        return res.json({ post });
    }

    res.json({ error: 'Not implemented' });

};

================
File: functions/create-post/package.json
================
{
  "name": "@biso/create-post",
  "version": "0.0.1",
  "module": "index.ts",
  "type": "module",
  "dependencies": {
    "bun-types": "latest",
    "zod": "1",
    "@biso/appwrite": "0.0.1"
  }
}

================
File: functions/create-user-doc/index.ts
================
import { createAdminClient, createSessionClient, ID, Permission, Query, Role } from "@biso/appwrite";

type Context = {
    req: any;
    res: any;
    log: (msg: any) => void;
    error: (msg: any) => void;
};

interface UserDoc {
    email: string;
}

export default async ({ req, res, log, error }: Context) => {

    log('Starting function execution'); // Initial log to indicate the function has started

    if (req.method !== 'POST') {
        log('Invalid request method');
        return res.json({ error: 'Method Not Allowed' });
    }

    log('On User Created POST request');

    log('Request body received: ' + JSON.stringify(req.body)); // Log the request body for debugging

    const { userId } = req.body;

    log('Creating admin client');
    const { databases, users } = await createAdminClient();
    log('Admin client created successfully');

    log('Checking for existing user document with ID: ' + userId);
    const existingUser = await databases.listDocuments('app', 'user', [Query.equal('$id', userId)]);
    if (existingUser.total > 0) {
        log('Existing document found: ' + JSON.stringify(existingUser));
        return res.json({ status: 'ok', exists: true });
    } else {
        log('No existing document found for user ID: ' + userId);
    }

    log('Fetching account details for user ID: ' + userId);
    const account = await users.get(userId);
    log('Account details retrieved: ' + JSON.stringify(account));

    if (!account.email) {
        log('User has no email address');
        return res.json({ error: 'User has no email address' });
    } else {
        log('User email found: ' + account.email);
    }

    log('Creating new user document for user ID: ' + userId);
    const userDoc = await databases.createDocument('app', 'user', userId, {
        email: account.email
    }, [
        Permission.update(Role.user(userId)),
        Permission.delete(Role.user(userId))
    ]);
    log('User document created successfully: ' + JSON.stringify(userDoc));

    log('Function execution complete, returning response');
    return res.json({ status: 'ok', exists: false, userDoc, account });
}

================
File: functions/create-user-doc/package.json
================
{
  "name": "@biso/create-user-doc",
  "version": "0.0.1",
  "module": "index.ts",
  "type": "module",
  "dependencies": {
    "bun-types": "latest",
    "zod": "1",
    "@biso/appwrite": "0.0.1"
  }
}

================
File: functions/election-vote/index.ts
================
import { castVote, Models } from '@biso/appwrite';

type Context = {
    req: any;
    res: any;
    log: (msg: any) => void;
    error: (msg: any) => void;
};

interface IncomingVote {
    optionId: string;
    voterId: string;
    electionId: string;
    votingSessionId: string;
    votingItemId: string;
    weight: number;
}

export default async ({ req, res, log, error }: Context) => {
    try {

        log('Parsing request body...');
        const body = JSON.parse(req.body);
        const votes = body.votes as IncomingVote[] | undefined;

        if (!votes) {
            log('No votes provided.');
            return res.json({ error: 'No votes provided' });
        }

        log('Casting votes...');
        for (const vote of votes) {
            const castedVote = await castVote({
                optionId: vote.optionId,
                voterId: vote.voterId,
                electionId: vote.electionId,
                votingSessionId: vote.votingSessionId,
                votingItemId: vote.votingItemId,
                weight: vote.weight,
                voter: body.voter
            });
            if (castVote) {
                log('Vote cast: ' + JSON.stringify(castVote));
            } else {
                log('Vote not cast.');
                return res.json({ error: 'Vote not cast' });
            }
            
        }
        log('Votes cast.');
        return res.json({ success: 'Votes cast' });
    }
    catch (err: any) {
        log('An error occurred: ' + err);
        return res.json({ error: (err as Error).message });
    }
}

================
File: functions/election-vote/package.json
================
{
  "name": "@biso/election-vote",
  "version": "0.0.1",
  "module": "index.ts",
  "type": "module",
  "dependencies": {
    "bun-types": "latest",
    "zod": "1",
    "@biso/appwrite": "0.0.1"
  }
}

================
File: functions/extract-pdf/index.ts
================
import { extractTextFromPdf } from "@biso/utils";

================
File: functions/extract-pdf/package.json
================
{
    "name": "@biso/extract-pdf",
    "version": "0.0.1",
    "module": "index.ts",
    "type": "module",
    "dependencies": {
      "bun-types": "latest",
      "zod": "1",
      "@biso/utils": "0.0.1"
    }
  }

================
File: functions/get-instagram-posts-by-hashtag/index.ts
================
import { getMedia } from "@biso/instagram";

type Context = {
    req: any;
    res: any;
    log: (msg: any) => void;
    error: (msg: any) => void;
};

export default async ({ req, res, log, error }: Context) => {
    log('On Instagram Posts by Hashtag POST request');

    const { hashtag } = req.body;

    if (!hashtag) {
        log('Missing required parameters');
        return res.json({ error: 'Missing required parameters' });
    }

    const content = await getMedia(hashtag);

    return res.json({ content });
}

================
File: functions/get-instagram-posts-by-hashtag/package.json
================
{
    "name": "@biso/insta-posts-by-hashtag",
    "version": "0.0.1",
    "module": "index.ts",
    "type": "module",
    "dependencies": {
      "@biso/instagram": "0.0.1",
      "bun-types": "latest",
      "zod": "1"
    }
  }

================
File: functions/verify-biso-membership/index.ts
================
import { soapClient } from "@biso/twentyfour";
import { Query, createAdminClient } from "@biso/appwrite";

type Context = {
    req: any;
    res: any;
    log: (msg: any) => void;
    error: (msg: any) => void;
};

export default async ({ req, res, log, error }: Context) => {
    log(`Incoming request body: ${JSON.stringify(req.body)}`);
    
    const snumber = req.body;
    const cleanedSnumber = snumber.toString().replace(/[^0-9]/g, '');
    const studentId = parseInt(cleanedSnumber, 10);
    log(`Processing request for student ID: ${studentId}`);

    const { databases } = await createAdminClient();
    const { getAccessToken, userCategories } = soapClient(error, log);

    // Fetch active memberships
    log('Fetching active memberships from database...');
    const memberships = await databases.listDocuments('app', 'memberships', [
        Query.equal('status', true),
        Query.select(['$id', 'membership_id', 'name', 'price', 'category', 'status', 'expiryDate']),
    ]);

    if (!memberships.documents || memberships.documents.length === 0) {
        log('No active memberships found in database');
        return res.json({ error: 'No active memberships found' });
    }

    log('Available memberships in database:');
    memberships.documents.forEach(m => {
        log(`- ID: ${m.$id}, Name: "${m.name}", Category: ${m.category}, Expiry: ${m.expiryDate}`);
    });

    // Get access token
    log('Getting 24SevenOffice access token...');
    const accessToken = await getAccessToken();
    if (accessToken.status !== 'ok') {
        log('Failed to retrieve 24SevenOffice access token');
        return res.json({ error: 'Failed to retrieve access token' });
    }

    // Get customer categories
    log(`Fetching categories from 24SevenOffice for student ${studentId}...`);
    const customerCategories = await userCategories(accessToken.accessToken, studentId);
    
    if (customerCategories.status !== 'ok') {
        log(`Failed to retrieve customer categories. Error: ${JSON.stringify(customerCategories)}`);
        return res.json({ error: 'Failed to retrieve customer categories' });
    }

    // Log the categories from 24SevenOffice
    log('Category IDs from 24SevenOffice:');
    const categoryIds = customerCategories.data;
    categoryIds.forEach((categoryId: number) => {
        log(`- Category ID: ${categoryId}`);
    });

    // Sort memberships by expiry date
    const sortedMemberships = memberships.documents
        .sort((a, b) => new Date(b.expiryDate).getTime() - new Date(a.expiryDate).getTime());

    // Find matching membership with detailed logging
    log('Attempting to match 24SevenOffice category IDs with database memberships...');
    const latestMembership = sortedMemberships.find(membership => {
        const dbCategory = membership.category;
        log(`\nChecking membership: "${membership.name}" (Category: ${dbCategory})`);
        
        const hasMatch = categoryIds.some((categoryId: number) => {
            const isMatch = categoryId.toString() === dbCategory;
            log(`- Comparing with 24SevenOffice category ID: ${categoryId} -> ${isMatch ? 'MATCH' : 'no match'}`);
            return isMatch;
        });

        return hasMatch;
    });

    if (latestMembership) {
        log(`Found matching membership: ${JSON.stringify(latestMembership)}`);
        return res.json({ membership: latestMembership });
    } else {
        log('No matching membership found. Categories available:');
        log(`Database membership categories: ${memberships.documents.map(m => m.category).join(', ')}`);
        log(`24SevenOffice category IDs: ${categoryIds.join(', ')}`);
        return res.json({ error: 'No active membership found for this user' });
    }
};

================
File: functions/verify-biso-membership/package.json
================
{
    "name": "@biso/verify-biso-membership",
    "version": "0.0.1",
    "module": "index.ts",
    "type": "module",
    "dependencies": {
      "bun-types": "latest",
      "zod": "1",
      "@biso/utils": "0.0.1",
      "@biso/vipps": "0.0.1",
      "@biso/appwrite": "0.0.1"
    }
  }

================
File: functions/vipps-callback/index.ts
================
import { getCheckout, getPayment, getAccessToken } from "../../packages/vipps/src/index.js";
import { createAdminClient, Query } from "@biso/appwrite";
import { CryptoHasher } from "bun";

type Context = {
    req: any;
    res: any;
    log: (msg: any) => void;
    error: (msg: any) => void;
};

interface PaymentData {
    ok: boolean;
    data: {
      aggregate: {
        authorizedAmount: Amount;
        cancelledAmount: Amount;
        capturedAmount: Amount;
        refundedAmount: Amount;
      };
      amount: Amount;
      state: string;
      paymentMethod: PaymentMethod;
      profile: object;
      pspReference: string;
      redirectUrl: string;
      reference: string;
    };
  }
  
  interface Amount {
    currency: string;
    value: number;
  }
  
  interface PaymentMethod {
    type: string;
    cardBin: string;
  }

const hash = new CryptoHasher("sha256");

export default async ({ req, res, log, error }: Context) => {
    log('On Vipps Payment POST request');

    const webhookSecret = process.env.VIPPS_WEBHOOK_SECRET!;
    log("Request: " + JSON.stringify(req));

    const requestHeaders = req.headers;
const xMsContentSha256 = requestHeaders['x-ms-content-sha256'];

    const expectedContentHash = hash.update(req.body).digest("base64");

    if (expectedContentHash !== xMsContentSha256) {
        log('Invalid content hash');
        return res.json({ error: 'Invalid content hash' });
    }

    let body;
    try {
        body = typeof req.body === 'string' ? JSON.parse(req.body) : req.body;
    } catch (err) {
        if (err instanceof Error) {
            error('JSON Parse error: ' + err.message);
        } else {
            error('Unknown error during JSON parsing');
        }
        return res.json({ error: 'Invalid JSON' });
    }

    log('Retreiving access token...');
    const token = await getAccessToken();
    if (!token.ok) {
        log('Error fetching access token: ' + token.error);
        return res.json({ error: 'Failed to fetch access token' });
    }

    const { reference, name, amount, success } = body;
    log('Parsed request body: ' + JSON.stringify(body));

    if (!reference || !name || !amount || !success) {
        log('Missing required parameters');
        return res.json({ error: 'Missing required parameters' });
    }

    const payment = await getPayment({
        reference,
        token: token.data.access_token,
    });
    const { databases } = await createAdminClient();
    if (!payment.ok) {
        log('Error getting payment:' + payment.error);

        return res.json({ payment });
    }

    log('Payment found: ' + JSON.stringify(payment));

    const existingDoc = await databases.getDocument('app', 'payments', payment.data.reference, [
        Query.select(['membership_id', 'user_id'])
    ]);
    log("Existing doc: " + JSON.stringify(existingDoc));

    const studentId = await databases.getDocument('app', 'user', existingDoc.user_id, [
        Query.select(['$id', 'student_id'])
    ]);
    log("Student ID: " + JSON.stringify(studentId));

    const updateStudentMembership = await databases.updateDocument('app', 'student_id', studentId.student_id, {
        isMember: true,
        membership_ids: [existingDoc.membership_id],
        memberships: [existingDoc.membership_id],
    });

    log("Updated student membership: " + JSON.stringify(updateStudentMembership));

    const updatePayment = await databases.updateDocument('app', 'payments', payment.data.reference, {
        status: payment.data.state === 'AUTHORIZED' ? 'SUCCESS' : 'FAILED',
        paid_amount: payment.data.amount.value,
        payment_method: payment.data.paymentMethod.type,
    })

    log('Payment document updated: ' + JSON.stringify(updatePayment));

    return res.json({ payment, studentId });

}

================
File: functions/vipps-callback/package.json
================
{
    "name": "@biso/vipps-callback",
    "version": "0.0.1",
    "module": "index.ts",
    "type": "module",
    "dependencies": {
      "bun-types": "latest",
      "zod": "1",
      "@biso/utils": "0.0.1",
      "@biso/vipps": "0.0.1",
      "@biso/appwrite": "0.0.1"
    }
  }

================
File: functions/vipps-payment/index.ts
================
import { createPayment, getAccessToken, EPaymentMethodType } from "@biso/vipps";
import { createSessionClient, ID } from "@biso/appwrite";

type Context = {
    req: any;
    res: any;
    log: (msg: any) => void;
    error: (msg: any) => void;
};
interface Body {
  amount: number;
  description: string;
  returnUrl: string;
  membershipId: string;
  phoneNumber: string;
  paymentMethod: EPaymentMethodType;
  membershipName: string;
}

export default async ({ req, res, log, error }: Context) => {
    log('On Vipps Payment POST request');
    log('Fetching access token...');
    const token = await getAccessToken();
    log('Request body: ' + JSON.stringify(req.body));
    log('Access token fetched: ' + JSON.stringify(token));

    // Ensure the body is parsed correctly
   const body = JSON.parse(req.body);

    const { amount, description, returnUrl, membershipId, phoneNumber, paymentMethod, membershipName } = body;
    log('Parsed request body: ' + JSON.stringify(body));

    if (!amount || !description || !returnUrl) {
        log('Missing required parameters');
        return res.json({ error: 'Missing required parameters' });
    }

    const reference = ID.unique();

    if (token.ok) {
    try {
        const checkout = await createPayment({
            reference,
            amount,
            description,
            returnUrl,
            token: token.data.access_token,
            membershipId,
            phoneNumber,
            paymentMethod,
            membershipName,
        });

        if (checkout.ok) {
            log('Checkout created: ' + JSON.stringify(checkout));
            log('Initiating Session Client...');
            const { databases, account } = await createSessionClient(req.headers['x-appwrite-user-jwt'] as string);

            log('Creating checkout document...');

            const user = await account.get();

            const doc = await databases.createDocument('app', 'payments', reference, {
                reference,
                amount,
                description,
                membership: membershipId as string,
                membership_id: membershipId as string,
                status: 'CREATED',
                user_id: user.$id,
                user: user.$id,
            });

            log('Checkout document created: ' + JSON.stringify(doc));
            
            return res.json({ checkout });
        } else {
            log('Error initiating checkout: ' + JSON.stringify(checkout.error));
            return res.json({ error: 'Failed to initiate checkout' });
        }
    } catch (err) {
        if (err instanceof Error) {
            log('Error initiating checkout: ' + err.message);
            return res.json({ error: 'Failed to initiate checkout', details: err.message });
        } else {
            log('Unknown error initiating checkout: ' + err);
            return res.json({ error: 'Failed to initiate checkout', details: 'Unknown error occurred' });
        }
    }
}
}

================
File: functions/vipps-payment/package.json
================
{
    "name": "@biso/vipps-payment",
    "version": "0.0.1",
    "module": "index.ts",
    "type": "module",
    "dependencies": {
      "bun-types": "latest",
      "zod": "1",
      "@biso/utils": "0.0.1",
      "@biso/vipps": "0.0.1",
      "@biso/appwrite": "0.0.1"
    }
  }

================
File: functions/webshop-product/index.ts
================
import axios from 'axios';

type Context = {
    req: any;
    res: any;
    log: (msg: any) => void;
    error: (msg: any) => void;
};

interface Product {
    id: number;
    name: string;
    campus: { value: string; label: string };
    department: { value: string; label: string };
    images: string[];
    price: string;
    sale_price: string;
    short_description: string;
    description: string;
    url: string;
}

export default async ({ req, res, log, error }: Context) => {
    log('Request received');

    // Get product ID from request body
    log("Request body: " + JSON.stringify(req.body));
   const productId = req.body
    try {
        // Fetch specific product from WooCommerce API
        const response = await axios.get(`https://biso.no/wp-json/wc/v3/products/${productId}`, {
            params: {
                consumer_key: process.env.WC_CONSUMER_KEY,
                consumer_secret: process.env.WC_CONSUMER_SECRET,
            },
        });

        const product = response.data;
        log(`Product fetched: ${JSON.stringify(product)}`);
        // Transform the product data to match your interface
        const transformedProduct: Product = {
            id: product.id,
            name: product.name,
            campus: product.acf?.campus || { value: '', label: 'N/A' },
            department: product.acf?.department || { value: '', label: 'N/A' },
            images: product.images.map((img: any) => img.src),
            price: product.price,
            sale_price: product.sale_price,
            short_description: product.short_description,
            description: product.description,
            url: product.permalink,
        };
        log(`Transformed product: ${JSON.stringify(transformedProduct)}`);
        return res.json({ product: transformedProduct });
    } catch (err: any) {
        error(`Error during product retrieval: ${err.message}`);
        if (err.response?.status === 404) {
            return res.json({ message: 'Product not found' });
        }

        error(`Failed to fetch product from WooCommerce: ${err.message}`);
        return res.json({ message: 'Failed to fetch product' });
    }
};

================
File: functions/webshop-product/package.json
================
{
  "name": "@biso/webshop-product",
  "version": "0.0.1",
  "module": "index.ts",
  "type": "module",
  "dependencies": {
    "bun-types": "latest",
    "zod": "1"
  }
}

================
File: packages/appwrite/src/castVote.ts
================
import { ID, Permission, Role, Models } from 'node-appwrite';
import { createAdminClient } from './index.js';

export async function castVote({
    optionId,
    voterId,
    electionId,
    votingSessionId,
    votingItemId,
    weight
    }: {
        optionId: string,
        voterId: string,
        electionId: string,
        votingSessionId: string,
        votingItemId: string,
        weight: number,
        voter: Models.Document
}) {
    const { databases } = await createAdminClient();

    const voter = await databases.getDocument('app', 'election_users', voterId)

    if (voter.canVote === false) return null;

            try {
            const castVote = await databases.createDocument('app', 'election_vote', ID.unique(), {
                optionId,
                voterId,
                electionId,
                votingSessionId,
                votingItemId,
                weight,
                voter: voter.$id
            }, [
                Permission.read(Role.user(voterId)),
                Permission.read(Role.team(electionId, 'owner')),
                Permission.delete(Role.user(electionId, 'owner')),
            ]);

            return castVote;
        }
        catch (err: any) {
            console.log(err);
            return null;
        }
}

================
File: packages/appwrite/src/chatGroup.ts
================
import { ID, Permission, Role, Models } from 'node-appwrite';
import { createSessionClient } from './index.js';

export async function createTeam({
    jwt,
    teamName,
    users,
    emails,
    log
}: {
    jwt: string,
    teamName: string,
    users?: Models.Document[],
    emails?: string[],
    log: (msg: any) => void
}) {
    log('Creating session client...');
    const { account, databases, storage, teams } = await createSessionClient(jwt);
    log('Session client created.');

    log('Fetching user account...');
    const user = await account.get();
    log('User account fetched: ' + JSON.stringify(user));

    const teamId = ID.unique();
    log('Generated team ID: ' + teamId);

    log(`Creating team with name: ${teamName}...`);
    const team = await teams.create(teamId, teamName);
    log('Team created: ' + JSON.stringify(team));

    if (team.$id) {
        log('Updating user document with new team info...');
        const teamDocument = await databases.updateDocument('app', 'user', user.$id, {
            chats: [{
                name: teamName
            }]
        }, [
            Permission.read(Role.team(teamId)),
            Permission.update(Role.team(teamId)),
            Permission.delete(Role.user(user.$id)),
            Permission.write(Role.team(teamId))
        ]);
        log('User document updated: ' + JSON.stringify(teamDocument));

        log(`Adding team ID ${teamId} to user's chats...`);
        await databases.updateDocument('app', 'user', user.$id, { chats: [teamId] });
        log('Team ID added to user\'s chats.');

        if (users) {
            log('Adding users to the team memberships...');
            for (const user of users) {
                log(`Creating membership for user: ${user.$id}...`);
                await teams.createMembership(teamId, [], "", user.$id, undefined, "https://669544b0281f8e2277e6.appwrite.biso.no/");
                log(`Membership created for user: ${user.$id}`);
            }
        }

        if (emails) {
            log('Adding emails to the team memberships...');
            for (const email of emails) {
                log(`Creating membership for email: ${email}...`);
                await teams.createMembership(teamId, [], email, undefined, undefined, "https://669544b0281f8e2277e6.appwrite.biso.no/");
                log(`Membership created for email: ${email}`);
            }
        }
    }

    log('Team creation complete. Returning team ID: ' + teamId);
    return teamId;
}

================
File: packages/appwrite/src/index.ts
================
import { Client, Databases, Users, Account, Storage, Functions, Teams } from "node-appwrite";
import zod from "zod";

// Function to create a session client using JWT from headers
export async function createSessionClient(jwt: string) {
    const client = new Client()
        .setEndpoint('https://appwrite.biso.no/v1')
        .setProject('biso');
  
    client.setJWT(jwt);
  
    return {
        get account() {
            return new Account(client);
        },
        get databases() {
            return new Databases(client);
        },
        get users() {
            return new Users(client);
        },
        get storage() {
            return new Storage(client);
        },
        get functions() {
            return new Functions(client);
        },
        get teams() {
            return new Teams(client);
        }
    };
}
  
// Function to create an admin client using API key
export async function createAdminClient() {
    const client = new Client()
        .setEndpoint('https://appwrite.biso.no/v1')
        .setProject('biso')
        .setKey(process.env.API_KEY!);
  
    return {
        get account() {
            return new Account(client);
        },
        get databases() {
            return new Databases(client);
        },
        get users() {
            return new Users(client);
        },
        get storage() {
            return new Storage(client);
        },
        get functions() {
            return new Functions(client);
        }
    };
}

================
File: packages/appwrite/.gitignore
================
# Based on https://raw.githubusercontent.com/github/gitignore/main/Node.gitignore

# Logs

logs
_.log
npm-debug.log_
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)

report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# Runtime data

pids
_.pid
_.seed
\*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover

lib-cov

# Coverage directory used by tools like istanbul

coverage
\*.lcov

# nyc test coverage

.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)

.grunt

# Bower dependency directory (https://bower.io/)

bower_components

# node-waf configuration

.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)

build/Release

# Dependency directories

node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)

web_modules/

# TypeScript cache

\*.tsbuildinfo

# Optional npm cache directory

.npm

# Optional eslint cache

.eslintcache

# Optional stylelint cache

.stylelintcache

# Microbundle cache

.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history

.node_repl_history

# Output of 'npm pack'

\*.tgz

# Yarn Integrity file

.yarn-integrity

# dotenv environment variable files

.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)

.cache
.parcel-cache

# Next.js build output

.next
out

# Nuxt.js build / generate output

.nuxt
dist

# Gatsby files

.cache/

# Comment in the public line in if your project uses Gatsby and not Next.js

# https://nextjs.org/blog/next-9-1#public-directory-support

# public

# vuepress build output

.vuepress/dist

# vuepress v2.x temp and cache directory

.temp
.cache

# Docusaurus cache and generated files

.docusaurus

# Serverless directories

.serverless/

# FuseBox cache

.fusebox/

# DynamoDB Local files

.dynamodb/

# TernJS port file

.tern-port

# Stores VSCode versions used for testing VSCode extensions

.vscode-test

# yarn v2

.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.\*

================
File: packages/appwrite/index.ts
================
export * from './src/chatGroup.js';
export * from './src/castVote.js';
export * from './src/index.js';
export * from 'node-appwrite';

================
File: packages/appwrite/package.json
================
{
  "name": "@biso/appwrite",
  "version": "0.0.1",
  "module": "index.ts",
  "type": "module",
  "dependencies": {
    "bun-types": "latest",
    "node-appwrite": "^14.1.0",
    "zod": "1"
  }
}

================
File: packages/appwrite/README.md
================
# Appwrite Integration Package

This package provides utilities and helper functions for interacting with the Appwrite backend services used in BISO applications.

## 📦 Installation

```bash
bun install
# or
yarn install
```

## 🔧 Configuration

The package requires the following environment variables (In the root of the monorepo):

```env
APPWRITE_ENDPOINT=your_appwrite_endpoint
APPWRITE_PROJECT_ID=your_project_id
APPWRITE_API_KEY=your_api_key
```

## 🚀 Usage

### Directly call Appwrite methods from a function
```typescript
import { createDocument, ID } from '@biso/appwrite';

// Example: Create a document
const document = await createDocument(
  'database_id',
  'collection_id',
  'document_id', // Or use the ID class provided. e.g ID.unique() to generate a unique ID.
  {
    property: 'some-data'
  }
);
```
### Create a function in the package.
In addition to calling Appwrite APIs directly from a function endpoint, you may create the functions in the package, exposing only that function to the endpoint.
In packages/appwrite:
```typescript
import { createDocument, ID } from '@biso/appwrite'

export async function someFunction({
  databaseId,
  collectionId,
  documentId,
  data
}: {
  databaseId: string
  collectionId: string
  documentId?: string
  data: any //Do not use the any type.
}) {
  const document = await createDocument(
    databaseId,
    collectionId,
    documentId ?? ID.unique(),
    data
)}
```
In functions/some-function:
```typescript
import { someFunction } from '@biso/appwrite'

const document = await someFunction({
  databaseId: 'database_id',
  collectionId: 'collection_id',
  data: {
    property: 'some_data'
  }
})
```

## 📚 Frequently used methods

### Database Operations
- `createDocument()`: Create a new document in a collection
- `getDocument()`: Retrieve a document by ID
- `updateDocument()`: Update an existing document
- `deleteDocument()`: Delete a document by ID

### Storage
- `uploadFile()`: Upload a file to Appwrite storage
- `getFile()`: Get file details and download URL
- `deleteFile()`: Delete a file from storage

## 🔐 Security

- Never commit API keys or sensitive credentials
- Always use environment variables for configuration
- Follow BISO's security guidelines for handling user data

## 🤝 Contributing

1. Create a new branch for your feature
2. Make your changes
3. Submit a pull request with a clear description of changes

## 📞 Support

For support, please contact:

**Markus Heien**  
IT Manager, BI Student Organization  
Email: [markus@biso.no](mailto:markus@biso.no)  
Phone: +47 98471622

---

*Part of the BISO Functions Monorepo*

================
File: packages/appwrite/tsconfig.json
================
{
  "compilerOptions": {
    "lib": [
      "ESNext"
    ],
    "module": "esnext",
    "target": "esnext",
    "moduleResolution": "nodenext",
    "strict": true,
    "downlevelIteration": true,
    "skipLibCheck": true,
    "jsx": "preserve",
    "allowSyntheticDefaultImports": true,
    "forceConsistentCasingInFileNames": true,
    "allowJs": true,
    "types": [
      "bun-types" // add Bun global
    ]
  }
}

================
File: packages/instagram/index.ts
================
import { FacebookAdsApi, IGMedia, InstagramMedia, IGUser } from 'facebook-nodejs-business-sdk';

const accessToken = process.env.FACEBOOK_ACCESS_TOKEN!;
const api = new FacebookAdsApi(accessToken);
const user = new IGUser(null, undefined, null, api);
export async function getMedia({
    hashtag
}: {
    hashtag?: string;
}) {
    const medias = await user.getMedia([], undefined, true);
    return medias.sourceObject;
}

================
File: packages/instagram/package.json
================
{
  "name": "@biso/instagram",
  "version": "0.0.1",
  "module": "index.ts",
  "type": "module",
  "dependencies": {
    "bun-types": "latest",
    "facebook-nodejs-business-sdk": "^20.0.0",
    "zod": "3"
  },
  "devDependencies": {
    "@types/facebook-nodejs-business-sdk": "^20.0.2"
  }
}

================
File: packages/instagram/README.md
================
# Instagram Integration Package

This package provides utilities for interacting with the Instagram Graph API, allowing BISO applications to fetch posts, manage content, and interact with Instagram's platform.

## 📦 Installation

```bash
bun install
# or
yarn install
```

## 🔧 Configuration

The package requires the following environment variables:

```env
INSTAGRAM_ACCESS_TOKEN=your_access_token
INSTAGRAM_BUSINESS_ACCOUNT_ID=your_business_account_id
```

## 🚀 Usage

```typescript
import { getPostsByHashtag, getMediaDetails } from '@biso/instagram';

// Example: Fetch posts by hashtag
const posts = await getPostsByHashtag('biso', { limit: 10 });

// Example: Get media details
const mediaDetails = await getMediaDetails('media_id');
```

## 📚 Available Functions

### Post Management
- `getPostsByHashtag()`: Fetch posts by hashtag
- `getMediaDetails()`: Get detailed information about a media item
- `getRecentMedia()`: Fetch recent media from a business account

### Account Information
- `getAccountInfo()`: Get information about the connected Instagram account
- `getAccountInsights()`: Fetch account insights and metrics

### Media Interactions
- `getMediaComments()`: Fetch comments on a media item
- `getMediaInsights()`: Get insights for a specific media item

## 🔐 Security

- Store Instagram access tokens securely
- Never commit tokens or sensitive credentials
- Follow Instagram's API usage guidelines and rate limits
- Adhere to BISO's security protocols

## ⚠️ Rate Limits

- Be aware of Instagram Graph API rate limits
- Implement appropriate caching strategies
- Handle rate limit errors gracefully

## 🤝 Contributing

1. Create a new branch for your feature
2. Make your changes
3. Submit a pull request with a clear description of changes

## 📞 Support

For support, please contact:

**Markus Heien**  
IT Manager, BI Student Organization  
Email: [markus@biso.no](mailto:markus@biso.no)  
Phone: +47 98471622

---

*Part of the BISO Functions Monorepo*

================
File: packages/twentyfour/src/accountService.ts
================
import { soapClient } from "./soapClient.js";
import axios from 'axios';
import { parseStringPromise } from 'xml2js';
import {
    BundleList,
    AccountData,
    EntryItem,
    LinkEntryItem,
    SaveBundleListResult,
    GetEntryIdResult,
    ArgEntryId,
    TypeData,
    TaxCodeElement,
    TaxMappingList,
    AccountDataError
} from './types.js';

const ACCOUNT_SERVICE_URL = 'https://api.24sevenoffice.com/Economy/Account/V004/Accountservice.asmx';

export const accountService = (error: (msg: any) => void, log: (msg: any) => void) => {
    const { getAccessToken } = soapClient(error, log);

    async function saveBundleList(token: string, bundleList: BundleList): Promise<SaveBundleListResult> {
        const body = `<?xml version="1.0" encoding="utf-8"?>
        <soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
            <soap12:Body>
                <SaveBundleList xmlns="http://24sevenOffice.com/webservices">
                    <BundleList>
                        ${generateBundleListXml(bundleList)}
                    </BundleList>
                </SaveBundleList>
            </soap12:Body>
        </soap12:Envelope>`;

        const response = await makeRequest(token, body);
        return response['soap:Envelope']['soap:Body'].SaveBundleListResponse.SaveBundleListResult;
    }

    async function addLinkEntries(token: string, linkEntryItem: LinkEntryItem): Promise<boolean> {
        const body = `<?xml version="1.0" encoding="utf-8"?>
        <soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
            <soap12:Body>
                <AddLinkEntries xmlns="http://24sevenOffice.com/webservices">
                    <linkEntryItem>
                        <LineIds>${linkEntryItem.LineIds.map(id => `<guid>${id}</guid>`).join('')}</LineIds>
                        <LinkId>${linkEntryItem.LinkId}</LinkId>
                    </linkEntryItem>
                </AddLinkEntries>
            </soap12:Body>
        </soap12:Envelope>`;

        const response = await makeRequest(token, body);
        return response['soap:Envelope']['soap:Body'].AddLinkEntriesResponse.AddLinkEntriesResult === 'true';
    }

    async function checkAccountNo(token: string, accountList: AccountData[]): Promise<AccountDataError[]> {
        const body = `<?xml version="1.0" encoding="utf-8"?>
        <soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
            <soap12:Body>
                <CheckAccountNo xmlns="http://24sevenOffice.com/webservices">
                    <accountList>
                        ${accountList.map(account => generateAccountDataXml(account)).join('')}
                    </accountList>
                </CheckAccountNo>
            </soap12:Body>
        </soap12:Envelope>`;

        const response = await makeRequest(token, body);
        const result = response['soap:Envelope']['soap:Body'].CheckAccountNoResponse.CheckAccountNoResult;
        return result.AccountDataErrors.map((error: any) => error.Error);
    }

    async function createLink(token: string): Promise<number> {
        const body = `<?xml version="1.0" encoding="utf-8"?>
        <soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
            <soap12:Body>
                <CreateLink xmlns="http://24sevenOffice.com/webservices" />
            </soap12:Body>
        </soap12:Envelope>`;

        const response = await makeRequest(token, body);
        return parseInt(response['soap:Envelope']['soap:Body'].CreateLinkResponse.CreateLinkResult);
    }

    async function getAccountList(token: string): Promise<AccountData[]> {
        const body = `<?xml version="1.0" encoding="utf-8"?>
        <soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
            <soap12:Body>
                <GetAccountList xmlns="http://24sevenOffice.com/webservices" />
            </soap12:Body>
        </soap12:Envelope>`;

        const response = await makeRequest(token, body);
        const result = response['soap:Envelope']['soap:Body'].GetAccountListResponse.GetAccountListResult;
        return Array.isArray(result.AccountData) ? result.AccountData : [result.AccountData];
    }

    async function getEntryId(token: string, entryId: ArgEntryId): Promise<GetEntryIdResult> {
        const body = `<?xml version="1.0" encoding="utf-8"?>
        <soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
            <soap12:Body>
                <GetEntryId xmlns="http://24sevenOffice.com/webservices">
                    <argEntryId>
                        <Date>${entryId.Date}</Date>
                        <SortNo>${entryId.SortNo}</SortNo>
                        <EntryNo>${entryId.EntryNo}</EntryNo>
                    </argEntryId>
                </GetEntryId>
            </soap12:Body>
        </soap12:Envelope>`;

        const response = await makeRequest(token, body);
        return response['soap:Envelope']['soap:Body'].GetEntryIdResponse.GetEntryIdResult;
    }

    async function getTaxCodeList(token: string): Promise<TaxCodeElement[]> {
        const body = `<?xml version="1.0" encoding="utf-8"?>
        <soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
            <soap12:Body>
                <GetTaxCodeList xmlns="http://24sevenOffice.com/webservices" />
            </soap12:Body>
        </soap12:Envelope>`;

        const response = await makeRequest(token, body);
        const result = response['soap:Envelope']['soap:Body'].GetTaxCodeListResponse.GetTaxCodeListResult;
        return Array.isArray(result.TaxCodeElement) ? result.TaxCodeElement : [result.TaxCodeElement];
    }

    async function getTypeList(token: string): Promise<TypeData[]> {
        const body = `<?xml version="1.0" encoding="utf-8"?>
        <soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
            <soap12:Body>
                <GetTypeList xmlns="http://24sevenOffice.com/webservices" />
            </soap12:Body>
        </soap12:Envelope>`;

        const response = await makeRequest(token, body);
        const result = response['soap:Envelope']['soap:Body'].GetTypeListResponse.GetTypeListResult;
        return Array.isArray(result.TypeData) ? result.TypeData : [result.TypeData];
    }

    async function replaceLinkEntries(token: string, linkEntryItem: LinkEntryItem): Promise<boolean> {
        const body = `<?xml version="1.0" encoding="utf-8"?>
        <soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
            <soap12:Body>
                <ReplaceLinkEntries xmlns="http://24sevenOffice.com/webservices">
                    <linkEntryItem>
                        <LineIds>${linkEntryItem.LineIds.map(id => `<guid>${id}</guid>`).join('')}</LineIds>
                        <LinkId>${linkEntryItem.LinkId}</LinkId>
                    </linkEntryItem>
                </ReplaceLinkEntries>
            </soap12:Body>
        </soap12:Envelope>`;

        const response = await makeRequest(token, body);
        return response['soap:Envelope']['soap:Body'].ReplaceLinkEntriesResponse.ReplaceLinkEntriesResult === 'true';
    }

    async function updateEntryDueDate(token: string, entryItems: EntryItem[]): Promise<EntryItem[]> {
        const body = `<?xml version="1.0" encoding="utf-8"?>
        <soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
            <soap12:Body>
                <UpdateEntryDueDate xmlns="http://24sevenOffice.com/webservices">
                    <entryItems>
                        ${entryItems.map(item => `
                            <EntryItem>
                                <LineId>${item.LineId}</LineId>
                                <DueDate>${item.DueDate}</DueDate>
                            </EntryItem>
                        `).join('')}
                    </entryItems>
                </UpdateEntryDueDate>
            </soap12:Body>
        </soap12:Envelope>`;

        const response = await makeRequest(token, body);
        const result = response['soap:Envelope']['soap:Body'].UpdateEntryDueDateResponse.UpdateEntryDueDateResult;
        return Array.isArray(result.EntryItem) ? result.EntryItem : [result.EntryItem];
    }

    // Helper functions
    function generateBundleListXml(bundleList: BundleList): string {
        const bundlesXml = bundleList.Bundles.map(bundle => `
            <Bundle>
                <YearId>${bundle.YearId}</YearId>
                <Vouchers>${generateVouchersXml(bundle.Vouchers)}</Vouchers>
                <Sort>${bundle.Sort}</Sort>
                <Name>${bundle.Name}</Name>
                <BundleDirectAccounting>${bundle.BundleDirectAccounting}</BundleDirectAccounting>
            </Bundle>
        `).join('');

        const ignoreWarningsXml = bundleList.IgnoreWarnings ? 
            `<IgnoreWarnings>${bundleList.IgnoreWarnings.map(warning => `<string>${warning}</string>`).join('')}</IgnoreWarnings>` : '';

        return `
            <Bundles>${bundlesXml}</Bundles>
            <SaveOption>${bundleList.SaveOption}</SaveOption>
            <DirectLedger>${bundleList.DirectLedger}</DirectLedger>
            <DefaultCustomerId>${bundleList.DefaultCustomerId}</DefaultCustomerId>
            <AllowDifference>${bundleList.AllowDifference}</AllowDifference>
            ${ignoreWarningsXml}
        `;
    }

    function generateVouchersXml(vouchers: any[]): string {
        return vouchers.map(voucher => `
            <Voucher>
                <TransactionNo>${voucher.TransactionNo}</TransactionNo>
                <Entries>${generateEntriesXml(voucher.Entries)}</Entries>
                <Sort>${voucher.Sort}</Sort>
                ${voucher.DifferenceOptions ? `<DifferenceOptions>${voucher.DifferenceOptions}</DifferenceOptions>` : ''}
            </Voucher>
        `).join('');
    }

    function generateEntriesXml(entries: any[]): string {
        return entries.map(entry => `
            <Entry>
                ${entry.SequenceId ? `<SequenceId>${entry.SequenceId}</SequenceId>` : ''}
                ${entry.CustomerId ? `<CustomerId>${entry.CustomerId}</CustomerId>` : ''}
                <AccountNo>${entry.AccountNo}</AccountNo>
                <Date>${entry.Date}</Date>
                ${entry.DueDate ? `<DueDate>${entry.DueDate}</DueDate>` : ''}
                <Amount>${entry.Amount}</Amount>
                ${entry.CurrencyId ? `<CurrencyId>${entry.CurrencyId}</CurrencyId>` : ''}
                ${entry.CurrencyRate ? `<CurrencyRate>${entry.CurrencyRate}</CurrencyRate>` : ''}
                ${entry.CurrencyUnit ? `<CurrencyUnit>${entry.CurrencyUnit}</CurrencyUnit>` : ''}
                ${entry.DepartmentId ? `<DepartmentId>${entry.DepartmentId}</DepartmentId>` : ''}
                ${entry.ProjectId ? `<ProjectId>${entry.ProjectId}</ProjectId>` : ''}
                ${entry.InvoiceReferenceNo ? `<InvoiceReferenceNo>${entry.InvoiceReferenceNo}</InvoiceReferenceNo>` : ''}
                ${entry.InvoiceOcr ? `<InvoiceOcr>${entry.InvoiceOcr}</InvoiceOcr>` : ''}
                ${entry.TaxNo ? `<TaxNo>${entry.TaxNo}</TaxNo>` : ''}
                ${entry.PeriodDate ? `<PeriodDate>${entry.PeriodDate}</PeriodDate>` : ''}
                ${entry.Comment ? `<Comment>${entry.Comment}</Comment>` : ''}
                ${entry.StampNo ? `<StampNo>${entry.StampNo}</StampNo>` : ''}
                ${entry.BankAccountNo ? `<BankAccountNo>${entry.BankAccountNo}</BankAccountNo>` : ''}
                ${entry.LinkId ? `<LinkId>${entry.LinkId}</LinkId>` : ''}
                ${entry.Links ? `<Links>${entry.Links.map((link: string) => `<string>${link}</string>`).join('')}</Links>` : ''}
                ${entry.LineId ? `<LineId>${entry.LineId}</LineId>` : ''}
            </Entry>
        `).join('');
    }

    function generateAccountDataXml(account: AccountData): string {
        return `
            <AccountData>
                <AccountId>${account.AccountId}</AccountId>
                <AccountNo>${account.AccountNo}</AccountNo>
                <AccountName>${account.AccountName}</AccountName>
                <AccountTax>${account.AccountTax}</AccountTax>
                <TaxNo>${account.TaxNo}</TaxNo>
            </AccountData>
        `;
    }

    async function makeRequest(token: string, body: string) {
        try {
            const response = await axios.post(ACCOUNT_SERVICE_URL, body, {
                headers: {
                    'Content-Type': 'application/soap+xml; charset=utf-8',
                    'Cookie': 'ASP.NET_SessionId=' + token
                }
            });

            const parsedResponse = await parseStringPromise(response.data, {
                explicitArray: false,
                ignoreAttrs: true
            });

            return parsedResponse;
        } catch (err) {
            error(err);
            throw err;
        }
    }

    return {
        saveBundleList,
        addLinkEntries,
        checkAccountNo,
        createLink,
        getAccountList,
        getEntryId,
        getTaxCodeList,
        getTypeList,
        replaceLinkEntries,
        updateEntryDueDate
    };
};

================
File: packages/twentyfour/src/attachmentService.ts
================
import { soapClient } from "./soapClient.js";
import axios from 'axios';
import { parseStringPromise } from 'xml2js';
import { 
    FileType,
    FileLocation,
    FlagType,
    ImageFile,
    FileInfoParameters,
    MetaDataFields,
    ImageFrameInfo,
    KeyValuePair,
    CreateResult,
    GetFileInfoResult,
    GetSeriesResult,
    StampSeries
} from './types.js';

const ATTACHMENT_SERVICE_URL = 'https://webservices.24sevenoffice.com/Economy/Accounting/Accounting_V001/AttachmentService.asmx';

const CHUNK_SIZE = 1024 * 1024; // 1MB chunks

interface UploadAttachmentOptions {
    fileType: FileType;
    fileBuffer: Buffer;
    invoiceOcr?: string;
    pageNo?: number;
    customMetadata?: KeyValuePair[];
}

export const attachmentService = (error: (msg: any) => void, log: (msg: any) => void) => {
    const { getAccessToken } = soapClient(error, log);

    /**
     * Converts MetaDataFields to KeyValuePair array
     */
    function convertMetaDataToKeyValuePairs(metadata: MetaDataFields): KeyValuePair[] {
        return Object.entries(metadata)
            .filter(([_, value]) => value !== undefined)
            .map(([key, value]) => ({
                Key: key,
                Value: value.toString()
            }));
    }

    /**
     * Uploads an attachment following the complete flow:
     * 1. Creates a ghost file
     * 2. Uploads the file in chunks
     * 3. Gets a stamp number
     * 4. Saves the file with metadata
     */
    async function uploadAttachment(token: string, options: UploadAttachmentOptions): Promise<number> {
        try {
            // Step 1: Create ghost file
            log('Creating ghost file...');
            const createResult = await create(token, options.fileType);
            const fileId = createResult.Id;

            // Step 2: Upload file in chunks
            log('Uploading file chunks...');
            const totalChunks = Math.ceil(options.fileBuffer.length / CHUNK_SIZE);
            for (let i = 0; i < totalChunks; i++) {
                const start = i * CHUNK_SIZE;
                const end = Math.min(start + CHUNK_SIZE, options.fileBuffer.length);
                const chunk = options.fileBuffer.slice(start, end);
                const base64Chunk = chunk.toString('base64');

                await appendChunk(token, {
                    Id: fileId,
                    Type: options.fileType
                }, base64Chunk, start);

                log(`Uploaded chunk ${i + 1}/${totalChunks}`);
            }

            // Step 3: Get stamp number
            log('Getting stamp number...');
            const stampNo = await getStampNo(token);

            // Step 4: Save file with metadata
            log('Saving file with metadata...');
            const metadata: KeyValuePair[] = [
                ...(options.pageNo ? [{
                    Key: 'PageNo',
                    Value: options.pageNo.toString()
                }] : []),
                ...(options.invoiceOcr ? [{
                    Key: 'InvoiceOCR',
                    Value: options.invoiceOcr
                }] : []),
                ...(options.customMetadata || [])
            ];

            const file: ImageFile = {
                Id: fileId,
                Type: options.fileType,
                FrameInfo: [{
                    Id: 1,
                    StampNo: stampNo,
                    Status: 0,
                    MetaData: metadata
                }]
            };

            await save(token, file, FileLocation.Retrieval);
            log('File upload completed successfully');
            
            return stampNo;
        } catch (err) {
            error('Error uploading attachment:');
            error(err);
            throw err;
        }
    }

    async function appendChunk(token: string, file: ImageFile, buffer: string, offset: number): Promise<void> {
        const body = `<?xml version="1.0" encoding="utf-8"?>
        <soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
            <soap12:Body>
                <AppendChunk xmlns="http://24sevenoffice.com/webservices/economy/accounting/">
                    <file>${generateFileInfoXml(file)}</file>
                    <buffer>${buffer}</buffer>
                    <offset>${offset}</offset>
                </AppendChunk>
            </soap12:Body>
        </soap12:Envelope>`;

        await makeRequest(token, body);
    }

    async function appendChunkByLength(token: string, file: ImageFile, buffer: string, bufferLength: number, offset: number): Promise<void> {
        const body = `<?xml version="1.0" encoding="utf-8"?>
        <soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
            <soap12:Body>
                <AppendChunkByLength xmlns="http://24sevenoffice.com/webservices/economy/accounting/">
                    <file>${generateFileInfoXml(file)}</file>
                    <buffer>${buffer}</buffer>
                    <bufferLength>${bufferLength}</bufferLength>
                    <offset>${offset}</offset>
                </AppendChunkByLength>
            </soap12:Body>
        </soap12:Envelope>`;

        await makeRequest(token, body);
    }

    async function create(token: string, type: FileType): Promise<CreateResult> {
        const body = `<?xml version="1.0" encoding="utf-8"?>
        <soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
            <soap12:Body>
                <Create xmlns="http://24sevenoffice.com/webservices/economy/accounting/">
                    <type>${type}</type>
                </Create>
            </soap12:Body>
        </soap12:Envelope>`;

        const response = await makeRequest(token, body);
        return response['soap:Envelope']['soap:Body'].CreateResponse.CreateResult;
    }

    async function downloadChunk(token: string, file: ImageFile, offset: number, bufferSize: number): Promise<string> {
        const body = `<?xml version="1.0" encoding="utf-8"?>
        <soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
            <soap12:Body>
                <DownloadChunk xmlns="http://24sevenoffice.com/webservices/economy/accounting/">
                    <file>${generateFileInfoXml(file)}</file>
                    <offset>${offset}</offset>
                    <bufferSize>${bufferSize}</bufferSize>
                </DownloadChunk>
            </soap12:Body>
        </soap12:Envelope>`;

        const response = await makeRequest(token, body);
        return response['soap:Envelope']['soap:Body'].DownloadChunkResponse.DownloadChunkResult;
    }

    async function getChecksum(token: string, file: ImageFile): Promise<string> {
        const body = `<?xml version="1.0" encoding="utf-8"?>
        <soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
            <soap12:Body>
                <GetChecksum xmlns="http://24sevenoffice.com/webservices/economy/accounting/">
                    <file>${generateFileInfoXml(file)}</file>
                </GetChecksum>
            </soap12:Body>
        </soap12:Envelope>`;

        const response = await makeRequest(token, body);
        return response['soap:Envelope']['soap:Body'].GetChecksumResponse.GetChecksumResult;
    }

    async function getFileInfo(token: string, parameters: FileInfoParameters): Promise<GetFileInfoResult> {
        const body = `<?xml version="1.0" encoding="utf-8"?>
        <soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
            <soap12:Body>
                <GetFileInfo xmlns="http://24sevenoffice.com/webservices/economy/accounting/">
                    <parameters>${generateFileInfoParametersXml(parameters)}</parameters>
                </GetFileInfo>
            </soap12:Body>
        </soap12:Envelope>`;

        const response = await makeRequest(token, body);
        return response['soap:Envelope']['soap:Body'].GetFileInfoResponse.GetFileInfoResult;
    }

    async function getMaxRequestLength(token: string): Promise<number> {
        const body = `<?xml version="1.0" encoding="utf-8"?>
        <soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
            <soap12:Body>
                <GetMaxRequestLength xmlns="http://24sevenoffice.com/webservices/economy/accounting/" />
            </soap12:Body>
        </soap12:Envelope>`;

        const response = await makeRequest(token, body);
        return response['soap:Envelope']['soap:Body'].GetMaxRequestLengthResponse.GetMaxRequestLengthResult;
    }

    async function getSize(token: string, file: ImageFile): Promise<number> {
        const body = `<?xml version="1.0" encoding="utf-8"?>
        <soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
            <soap12:Body>
                <GetSize xmlns="http://24sevenoffice.com/webservices/economy/accounting/">
                    <file>${generateFileInfoXml(file)}</file>
                </GetSize>
            </soap12:Body>
        </soap12:Envelope>`;

        const response = await makeRequest(token, body);
        return response['soap:Envelope']['soap:Body'].GetSizeResponse.GetSizeResult;
    }

    async function save(token: string, file: ImageFile, location: FileLocation): Promise<void> {
        const body = `<?xml version="1.0" encoding="utf-8"?>
        <soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
            <soap12:Body>
                <Save xmlns="http://24sevenoffice.com/webservices/economy/accounting/">
                    <file>${generateFileInfoXml(file)}</file>
                    <location>${location}</location>
                </Save>
            </soap12:Body>
        </soap12:Envelope>`;

        await makeRequest(token, body);
    }

    async function getStampNo(token: string): Promise<number> {
        const body = `<?xml version="1.0" encoding="utf-8"?>
        <soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
            <soap12:Body>
                <GetStampNo xmlns="http://24sevenoffice.com/webservices/economy/accounting/" />
            </soap12:Body>
        </soap12:Envelope>`;

        const response = await makeRequest(token, body);
        return response['soap:Envelope']['soap:Body'].GetStampNoResponse.GetStampNoResult;
    }

    async function getApproverList(token: string): Promise<KeyValuePair[]> {
        const body = `<?xml version="1.0" encoding="utf-8"?>
        <soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
            <soap12:Body>
                <GetApproverList xmlns="http://24sevenoffice.com/webservices/economy/accounting/" />
            </soap12:Body>
        </soap12:Envelope>`;

        const response = await makeRequest(token, body);
        return response['soap:Envelope']['soap:Body'].GetApproverListResponse.GetApproverListResult.KeyValuePair;
    }

    async function getSeries(token: string): Promise<GetSeriesResult> {
        const body = `<?xml version="1.0" encoding="utf-8"?>
        <soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
            <soap12:Body>
                <GetSeries xmlns="http://24sevenoffice.com/webservices/economy/accounting/" />
            </soap12:Body>
        </soap12:Envelope>`;

        const response = await makeRequest(token, body);
        return response['soap:Envelope']['soap:Body'].GetSeriesResponse.GetSeriesResult;
    }

    async function getSeriesStampNo(token: string, seriesId: string): Promise<number> {
        const body = `<?xml version="1.0" encoding="utf-8"?>
        <soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
            <soap12:Body>
                <GetSeriesStampNo xmlns="http://24sevenoffice.com/webservices/economy/accounting/">
                    <SeriesId>${seriesId}</SeriesId>
                </GetSeriesStampNo>
            </soap12:Body>
        </soap12:Envelope>`;

        const response = await makeRequest(token, body);
        return response['soap:Envelope']['soap:Body'].GetSeriesStampNoResponse.GetSeriesStampNoResult;
    }

    // Helper functions
    function generateFileInfoXml(file: ImageFile): string {
        const stampMetaXml = file.StampMeta ? 
            `<StampMeta>${generateKeyValuePairXml(file.StampMeta)}</StampMeta>` : '';

        const frameInfoXml = file.FrameInfo ? 
            `<FrameInfo>${file.FrameInfo.map(frame => {
                const metaDataXml = frame.MetaData?.length 
                    ? `<MetaData>${frame.MetaData.map(meta => 
                        Object.entries(meta)
                            .filter(([_, value]) => value !== undefined)
                            .map(([key, value]) => `<${key}>${value}</${key}>`)
                            .join('')
                    ).join('')}</MetaData>`
                    : '<MetaData xsi:nil="true" />';

                return `<ImageFrameInfo>
                    <Id>1</Id>
                    <StampNo>${frame.StampNo}</StampNo>
                    ${metaDataXml}
                    <Status>0</Status>
                </ImageFrameInfo>`;
            }).join('')}</FrameInfo>` : '';

        const contactIdXml = file.ContactId ? 
            `<ContactId>${file.ContactId.map(id => `<int>${id}</int>`).join('')}</ContactId>` : '';

        return `
            <Id>${file.Id}</Id>
            <Type>${file.Type}</Type>
            ${file.StampNo ? `<StampNo>${file.StampNo}</StampNo>` : ''}
            ${stampMetaXml}
            ${frameInfoXml}
            ${contactIdXml}
        `;
    }

    function generateKeyValuePairXml(pairs: KeyValuePair[]): string {
        return pairs.map(pair => 
            `<KeyValuePair><Key>${pair.Key}</Key><Value>${pair.Value}</Value></KeyValuePair>`
        ).join('');
    }

    function generateFileInfoParametersXml(parameters: FileInfoParameters): string {
        const stampNoXml = parameters.StampNo ? 
            `<StampNo>${parameters.StampNo.map(no => `<int>${no}</int>`).join('')}</StampNo>` : '';
        
        const fileIdXml = parameters.FileId ? 
            `<FileId>${parameters.FileId.map(id => `<int>${id}</int>`).join('')}</FileId>` : '';

        const attachmentStatusXml = parameters.AttachmentStatus ? 
            `<AttachmentStatus>${parameters.AttachmentStatus.map(status => 
                `<FlagType>${status}</FlagType>`
            ).join('')}</AttachmentStatus>` : '';

        return `
            ${stampNoXml}
            ${fileIdXml}
            ${parameters.AttachmentRegisteredAfter ? `<AttachmentRegisteredAfter>${parameters.AttachmentRegisteredAfter}</AttachmentRegisteredAfter>` : ''}
            ${parameters.AttachmentChangedAfter ? `<AttachmentChangedAfter>${parameters.AttachmentChangedAfter}</AttachmentChangedAfter>` : ''}
            ${parameters.HasStampNo !== undefined ? `<HasStampNo>${parameters.HasStampNo}</HasStampNo>` : ''}
            ${parameters.FileApproved !== undefined ? `<FileApproved>${parameters.FileApproved}</FileApproved>` : ''}
            ${attachmentStatusXml}
        `;
    }

    async function makeRequest(token: string, body: string) {
        try {
            const response = await axios.post(ATTACHMENT_SERVICE_URL, body, {
                headers: {
                    'Content-Type': 'application/soap+xml; charset=utf-8',
                    'Cookie': 'ASP.NET_SessionId=' + token
                }
            });

            const parsedResponse = await parseStringPromise(response.data, {
                explicitArray: false,
                ignoreAttrs: true
            });

            return parsedResponse;
        } catch (err) {
            error(err);
            throw err;
        }
    }

    return {
        uploadAttachment,
        appendChunk,
        appendChunkByLength,
        create,
        downloadChunk,
        getChecksum,
        getFileInfo,
        getMaxRequestLength,
        getSize,
        save,
        getStampNo,
        getApproverList,
        getSeries,
        getSeriesStampNo
    };
};

================
File: packages/twentyfour/src/soapClient.ts
================
import { Models } from '@biso/appwrite';
import axios from 'axios';
import { parseStringPromise } from 'xml2js';
import fetch from 'node-fetch';

const AUTH_URL = 'https://api.24sevenoffice.com/authenticate/v001/authenticate.asmx';
const INVOICE_URL = 'https://api.24sevenoffice.com/Economy/InvoiceOrder/V001/InvoiceService.asmx';

interface InvoiceRow {
    ProductId?: number;
    Price?: number;
    Name?: string;
    Quantity?: number;
    DepartmentId?: number;
    ProjectId?: number;
}

interface UserDefinedDimensions {
    Type: UserDefinedDimensionKey;
    Name: string;
    Value: string;
    TypeId: string;
}

export enum UserDefinedDimensionKey {
    None = 'None',
    Department = 'Department',
    Employee = 'Employee',
    Project = 'Project',
    Product = 'Product',
    Customer = 'Customer',
    CustomerOrderSlip = 'CustomerOrderSlip',
    SupplierOrderSlip = 'SupplierOrderSlip',
    UserDefined = 'UserDefined'
}

interface InvoiceOrder {
    OrderId?: number; 
    CustomerId: number; 
    CustomerName?: string; 
    CustomerDeliveryName?: string; 
    CustomerDeliveryPhone?: string; 
    DeliveryAlternative?: string; 
    InvoiceId?: number; 
    DateOrdered?: Date; 
    DateInvoiced?: string; 
    DateChanged?: Date; 
    OrderStatus?: string;
    PaymentTime?: number; 
    CustomerReferenceNo?: string; 
    ProjectId?: number; 
    OurReference?: number; 
    IncludeVAT?: boolean | null; 
    YourReference?: string; 
    InvoiceTitle?: string; 
    InvoiceText?: string; 
    Paid?: Date; 
    CustomerOrgNo?: string; 
    PaymentMethodId?: number; 
    PaymentAmount?: number; 
    DepartmentId?: number; 
    ReferenceInvoiceId?: number; 
    ReferenceOrderId?: number; 
    ReferenceNumber?: string; 
    InvoiceEmailAddress?: string; 
    AccrualDate?: string; 
    AccrualLength?: number; 
    InvoiceRows?: InvoiceRow[]; 
    UserDefinedDimensions?: UserDefinedDimensions[]; 
}

interface Company {
  Id: number;
  Name: string; // Max length 200 characters
  FirstName?: string; // Max length 50 characters, only in use on Company Type ‘Consumer’
  Type: 'None' | 'Lead' | 'Consumer' | 'Business' | 'Supplier'; // Enum
  DistributionMethod?: 'Default' | 'Unchanged' | 'Print' | 'EMail' | 'ElectronicInvoice'; // Enum
  CurrencyId?: string; // Default: LOCAL
  PaymentTime?: number; // Special conditions described in the text
  GLNNumber?: string; // Default value: “”. Max length 13 characters
  Factoring?: boolean;
  LedgerCustomerAccount?: number; // The account number used for the customer ledger
  LedgerSupplierAccount?: number; // The account number used for the supplier ledger
  VatNumber?: string;
  Private?: boolean; // False = "visible to all", true = "visible to owner"
  ExplicitlySpecifyNewCompanyId?: boolean; // Set companyId explicitly
}

const sanitizeXmlString = (xml: string) => {
  return xml.replace(/\n/g, '').replace(/\r/g, '').replace(/\t/g, '');
};

export const soapClient = (error: (msg: any) => void, log: (msg: any) => void) => {

    const getAccessToken = async () => {
        const SOAP_BODY = `<?xml version="1.0" encoding="utf-8"?>
        <soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
          <soap12:Body>
            <Login xmlns="http://24sevenOffice.com/webservices">
              <credential>
                <ApplicationId>${process.env.TWENTYFOUR_APP_ID}</ApplicationId>
                <Password>${process.env.TWENTYFOUR_PASSWORD}</Password>
                <Username>${process.env.TWENTYFOUR_USERNAME}</Username>
              </credential>
            </Login>
          </soap12:Body>
        </soap12:Envelope>`;

        try {
            const response = await axios.post(AUTH_URL, SOAP_BODY, {
                headers: {
                    'Content-Type': 'application/soap+xml; charset=utf-8'
                }
            });

            if (response.status !== 200) {
                throw new Error('Failed to authenticate with 24sevenoffice');
            }

            const responseText = response.data;
            const match = responseText.match(/<LoginResult>(.*)<\/LoginResult>/);
            if (!match) {
                throw new Error('Access token not found in response');
            }
            return {
                accessToken: match[1],
                status: 'ok'
            }
        } catch (error) {
            log('Error during authentication: ' + error);
            return {
                status: 'error',
                error: error
            }
        }
    };

    const createInvoice = async (token: string, data: InvoiceOrder) => {
      // Manually concatenate the XML string parts without using template literals
      const invoiceRowsXML = data.InvoiceRows?.map(row => 
          `<InvoiceRow>
            <ProductId>${row.ProductId ?? ''}</ProductId>
            <Price>${row.Price ?? ''}</Price>
            <Quantity>${row.Quantity ?? ''}</Quantity>
          </InvoiceRow>`
      ).join('') || '';
    
      const userDefinedDimensionsXML = data.UserDefinedDimensions?.map(udd => 
          `<UserDefinedDimension>
            <Type>${udd.Type}</Type>
            <Name>${udd.Name}</Name>
            <Value>${udd.Name}</Value>
            <TypeId>${udd.TypeId}</TypeId>
          </UserDefinedDimension>`
      ).join('') || '';
      
    
      const SOAP_BODY = `<?xml version="1.0" encoding="utf-8"?>
      <soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                       xmlns:xsd="http://www.w3.org/2001/XMLSchema"
                       xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
        <soap12:Body>
          <SaveInvoices xmlns="http://24sevenOffice.com/webservices">
            <invoices>
              <InvoiceOrder>
                <CustomerId>${data.CustomerId}</CustomerId>
                <OrderStatus>${data.OrderStatus}</OrderStatus>
                <PaymentMethodId>${data.PaymentMethodId}</PaymentMethodId>
                <PaymentTime>${data.PaymentTime}</PaymentTime>
                <DateInvoiced>${data.DateInvoiced}</DateInvoiced>
                <PaymentAmount>${data.PaymentAmount}</PaymentAmount>
                <Distributor>Manual</Distributor>
                <DepartmentId>${data.DepartmentId}</DepartmentId>
                <InvoiceRows>${invoiceRowsXML}</InvoiceRows>
                <AccrualDate>${data.AccrualDate}</AccrualDate>
                <AccrualLength>${data.AccrualLength}</AccrualLength>
                <UserDefinedDimensions>${userDefinedDimensionsXML}</UserDefinedDimensions>
              </InvoiceOrder>
            </invoices>
          </SaveInvoices>
        </soap12:Body>
      </soap12:Envelope>`;
    
        // No need to sanitize if SOAP_BODY is constructed properly
        log('Invoice request body: ' + SOAP_BODY);
        try {
        const response = await axios.post(INVOICE_URL, SOAP_BODY, {
            headers: {
                'Content-Type': 'application/soap+xml; charset=utf-8',
                'Cookie': 'ASP.NET_SessionId=' + token
            }
        });
      
      
      const responseText = await response.data;
      log('Invoice response status: ' + response.status);
      log('Invoice response headers: ' + JSON.stringify(response.headers));
      log('Invoice response body: ' + responseText);
      
    
        return responseText;
      } catch (error) {
        log('Error during invoice creation: ' + error);
      }
    };
      
  
    const getCustomerCategories = async (token: string) => {
      try {
          const body = `<?xml version="1.0" encoding="utf-8"?>
          <soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
              <soap12:Body>
                  <GetCustomerCategoryTree xmlns="http://24sevenOffice.com/webservices" />
              </soap12:Body>
          </soap12:Envelope>`;

          const response = await axios.post('https://api.24sevenoffice.com/CRM/Company/V001/CompanyService.asmx', body, {
              headers: {
                  'Content-Type': 'application/soap+xml; charset=utf-8',
                  'Cookie': 'ASP.NET_SessionId=' + token
              }
          });

          const parsedResponse = await parseStringPromise(response.data, {
              explicitArray: false, // This option prevents arrays from being created for each element
              ignoreAttrs: true // This option ignores the attributes and only parses the values
          });

          // Extract the customer categories from the parsed response
          const categories = parsedResponse['soap:Envelope']['soap:Body']['GetCustomerCategoryTreeResponse']['GetCustomerCategoryTreeResult']['KeyValuePair'];
          return categories;

      } catch (error) {
          log('Error during customer category retrieval: ' + error);
          throw error;
      }
  };

  const searchCustomer = async (token: string, name?: string, email?: string) => {
    try {
      const body = `<?xml version="1.0" encoding="utf-8"?>
<soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
  <soap12:Body>
    <GetCompanies xmlns="http://24sevenOffice.com/webservices">
      <searchParams>
        <CompanyName>${name}</CompanyName>
      </searchParams>
      <returnProperties>
        <string>Id</string>
      </returnProperties>
    </GetCompanies>
  </soap12:Body>
</soap12:Envelope>`;

      const response = await axios.post('https://api.24sevenoffice.com/CRM/Company/V001/CompanyService.asmx', body, {
        headers: {
          'Content-Type': 'application/soap+xml; charset=utf-8',
          'Cookie': 'ASP.NET_SessionId=' + token
        }
      });

      const parsedResponse = await parseStringPromise(response.data, {
        explicitArray: false,
        ignoreAttrs: true
      });

      return parsedResponse['soap:Envelope']['soap:Body']['GetCompaniesResponse']['GetCompaniesResult']['Company'];

    } catch (error) {
      log('Error during customer search: ' + error);
      throw error;
    }
  };

  const userCategories = async (token: string, studentId: number) => {
    try {
        const body = `<?xml version="1.0" encoding="utf-8"?>
        <soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
            <soap12:Body>
                <GetCustomerCategories xmlns="http://24sevenOffice.com/webservices">
                    <customerId>${studentId}</customerId>
                </GetCustomerCategories>
            </soap12:Body>
        </soap12:Envelope>`;

        const response = await axios.post(
            'https://api.24sevenoffice.com/CRM/Company/V001/CompanyService.asmx',
            body,
            {
                headers: {
                    'Content-Type': 'application/soap+xml; charset=utf-8',
                    'Cookie': 'ASP.NET_SessionId=' + token
                }
            }
        );

        log(`Raw SOAP Response: ${response.data}`);

        const parsedResponse = await parseStringPromise(response.data, {
            explicitArray: false,
            ignoreAttrs: true
        });

        log(`Parsed Response: ${JSON.stringify(parsedResponse)}`);

        // Get the int values from GetCustomerCategoriesResult
        const result = parsedResponse['soap:Envelope']['soap:Body']['GetCustomerCategoriesResponse']['GetCustomerCategoriesResult'];
        let categories = result?.int || [];
        
        // If it's a single category, wrap it in an array
        if (!Array.isArray(categories)) {
            categories = [categories];
        }

        // Convert to numbers and filter out any invalid values
        const categoryIds = categories
            .map((cat: string) => parseInt(cat, 10))
            .filter((id: number) => !isNaN(id));

        log(`Extracted category IDs: ${JSON.stringify(categoryIds)}`);

        return {
            status: 'ok',
            data: categoryIds
        };

    } catch (error) {
        log(`Error during customer category retrieval: ${error}`);
        return {
            status: 'error',
            data: []
        };
    }
};

  const updateCustomerCategory = async (token: string, customerCategoryId: number, studentId: number) => {
    
    try {
        const body = `<?xml version="1.0" encoding="utf-8"?>
        <soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
          <soap12:Body>
            <SaveCustomerCategories xmlns="http://24sevenOffice.com/webservices">
              <customerCategories>
                <KeyValuePair>
                  <Key>${customerCategoryId}</Key>
                  <Value>${studentId}</Value>
                </KeyValuePair>
              </customerCategories>
            </SaveCustomerCategories>
          </soap12:Body>
        </soap12:Envelope>`;

        const response = await axios.post('https://api.24sevenoffice.com/CRM/Company/V001/CompanyService.asmx', body, {
            headers: {
                'Content-Type': 'application/soap+xml; charset=utf-8',
                'Cookie': 'ASP.NET_SessionId=' + token
            }
        });

        const parsedResponse = await parseStringPromise(response.data, {
            explicitArray: false, // This option prevents arrays from being created for each element
            ignoreAttrs: true // This option ignores the attributes and only parses the values
        });

        // Extract the customer categories from the parsed response
        const apiExceptions = parsedResponse['soap:Envelope']['soap:Body']['SaveCustomerCategoriesResponse']['SaveCustomerCategoriesResult'];
        if (apiExceptions) {
            throw new Error(apiExceptions['ApiException']['Message']);
        }

        return true;

    } catch (error) {
        log('Error during customer category update: ' + error);
        throw error;
    }
};
const getCustomer = async (token: string, customerId: number) => {
    //A student ID looks like this: s1715738. remove the s

  try {
    const body = `<?xml version="1.0" encoding="utf-8"?>
    <soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
      <soap12:Body>
        <GetCompanies xmlns="http://24sevenOffice.com/webservices">
          <searchParams>
            <CompanyId>${customerId}</CompanyId>
          </searchParams>
          <returnProperties>
            <string>Name</string>
          </returnProperties>
        </GetCompanies>
      </soap12:Body>
    </soap12:Envelope>`;

    const response = await axios.post('https://api.24sevenoffice.com/CRM/Company/V001/CompanyService.asmx', body, {
        headers: {
            'Content-Type': 'application/soap+xml; charset=utf-8',
            'Cookie': 'ASP.NET_SessionId=' + token
        }
    });

    const parsedResponse = await parseStringPromise(response.data, {
        explicitArray: false, // Prevent arrays for single elements
        ignoreAttrs: true // Ignore attributes
    });

    // Extract the customer(s) from the parsed response
    const companies = parsedResponse['soap:Envelope']['soap:Body']['GetCompaniesResponse']?.['GetCompaniesResult']?.['Company'];

    // Ensure that there is at least one company in the response
    if (!companies) {
        throw new Error('No companies found in the response');
    }

    // If companies is an array, return the first company, otherwise return the single company object
    return Array.isArray(companies) ? companies[0] : companies;

  } catch (error) {
    log('Error during customer retrieval: ' + error);
    throw error;
  }
};

const getCustomerByExternalId = async (token: string, customerId: number) => {
  //A student ID looks like this: s1715738. remove the s

try {
  const body = `<?xml version="1.0" encoding="utf-8"?>
  <soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
    <soap12:Body>
      <GetCompanies xmlns="http://24sevenOffice.com/webservices">
        <searchParams>
          <ExternalId>${customerId}</ExternalId>
        </searchParams>
        <returnProperties>
          <string>Name</string>
          <string>CompanyId</string>
        </returnProperties>
      </GetCompanies>
    </soap12:Body>
  </soap12:Envelope>`;

  const response = await axios.post('https://api.24sevenoffice.com/CRM/Company/V001/CompanyService.asmx', body, {
      headers: {
          'Content-Type': 'application/soap+xml; charset=utf-8',
          'Cookie': 'ASP.NET_SessionId=' + token
      }
  });

  const parsedResponse = await parseStringPromise(response.data, {
      explicitArray: false, // Prevent arrays for single elements
      ignoreAttrs: true // Ignore attributes
  });

  // Extract the customer(s) from the parsed response
  const companies = parsedResponse['soap:Envelope']['soap:Body']['GetCompaniesResponse']?.['GetCompaniesResult']?.['Company'];

  // Ensure that there is at least one company in the response
  if (!companies) {
      throw new Error('No companies found in the response');
  }

  // If companies is an array, return the first company, otherwise return the single company object
  return Array.isArray(companies) ? companies[0] : companies;

} catch (error) {
  log('Error during customer retrieval: ' + error);
  throw error;
}
};




const createCustomer = async (token: string, user: Partial<Models.Document>) => {

  const studentId = parseInt(user.student_id.replace('s', ''));
  try {
    const firstName = user.name.split(' ')[0];

    const body = `<?xml version="1.0" encoding="utf-8"?>
    <soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
      <soap12:Body>
        <SaveCompanies xmlns="http://24sevenOffice.com/webservices">
          <companies>
            <Company>
              <Id>${studentId}</Id>
              <Name>(Student) ${user.name}</Name>
              <FirstName>${firstName}</FirstName>
              <Type>Consumer</Type>
            </Company>
          </companies>
        </SaveCompanies>
      </soap12:Body>
    </soap12:Envelope>`;

    const response = await axios.post('https://api.24sevenoffice.com/CRM/Company/V001/CompanyService.asmx', body, {
        headers: {
            'Content-Type': 'application/soap+xml; charset=utf-8',
            'Cookie': 'ASP.NET_SessionId=' + token
        }
    });

    const parsedResponse = await parseStringPromise(response.data, {
        explicitArray: false, // This option prevents arrays from being created for each element
        ignoreAttrs: true // This option ignores the attributes and only parses the values
    });

    // Extract the array of companies from the parsed response
    const companies = parsedResponse['soap:Envelope']['soap:Body']['SaveCompaniesResponse']?.['SaveCompaniesResult']?.['Company'];

    // Ensure that there is at least one company in the response
    if (!companies) {
        throw new Error('No companies found in the response');
    } 

    // If companies is an array, return the first company, otherwise return the single company object
    return Array.isArray(companies) ? companies[0] : companies;

      } catch (error) {
          log('Error during customer creation: ' + error);
          throw error;
      }
};




    return {
        getAccessToken,
        createInvoice,
        getCustomerCategories,
        updateCustomerCategory,
        getCustomer,
        createCustomer,
        getCustomerByExternalId,
        userCategories,
        searchCustomer
    };
};

================
File: packages/twentyfour/src/types.ts
================
export interface InvoiceCustomer {
    id: number;
    organizationNumber?: string;
    gln?: string;
    name: string;
    street?: string;
    postalCode?: string;
    postalArea?: string;
    city?: string;
    countrySubdivision?: string;
    countryCode?: string;
}

export interface Invoice {
    number?: number;
    date?: string;
    dueDate?: string;
    remittanceReference?: string;
}

export enum Status {
    DRAFT = 'Draft',
    PROPOSAL = 'Proposal',
    CONFIRMED = 'Confirmed',
    INVOICE = 'Invoice',
    ADVANCEINVOICE = 'AdvanceInvoice',
}

export interface SalesOrder {
    customer: InvoiceCustomer;
    status: Status;
    delieveryCustomer?: InvoiceCustomer;
    invoice?: Invoice;
    date: string;
    internalMemo?: string;
    memo?: string;
    salesType?: {
        id: number;
    };
    createdAt?: string;
    modifiedAt?: string;
}

export interface ListOptions {
    limit: number;
    date?: string;
    dateFrom?: string;
    dateTo?: string;
    status?: Status;
    customerId?: number;
    invoiceNumber?: number;
    createdFrom?: string;
    createdTo?: string;
    modifiedFrom?: string;
    modifiedTo?: string;
}

export interface CustomerParams {
    limit?: number;
    isCompany?: boolean;
    isSupplier?: boolean;
    modifiedFrom?: string;
    createdFrom?: string;
    sortBy?: string;
}

export interface Customer {
    Id: number;
    Name: string;
}

// Account Service Types
export interface BundleList {
    Bundles: Bundle[];
    SaveOption: 0 | 1; // 0 = direct to ledger, 1 = save as journal (default)
    DirectLedger: boolean; // default false
    DefaultCustomerId: number;
    AllowDifference: boolean; // default false
    IgnoreWarnings?: string[]; // ['vatisnotinbalance', 'vatismissingfoundation', 'invoicealreadyexists', 'customermismatchbankaccount']
}

export interface Bundle {
    YearId: number; // e.g., 2024
    Vouchers: Voucher[];
    Sort: number; // Entry type from GetTransactionTypes
    Name: string;
    BundleDirectAccounting: boolean; // false = auto VAT calc, true = no VAT calc
}

export interface Voucher {
    TransactionNo: number;
    Entries: Entry[];
    Sort: number;
    DifferenceOptions?: any; // TODO: Define DifferenceOptions type if needed
}

export interface Entry {
    SequenceId?: number;
    CustomerId?: number;
    AccountNo: number;
    Date: string;
    DueDate?: string;
    Amount: number; // positive for debit, negative for credit
    CurrencyId?: string; // e.g., 'NOK', 'USD'
    CurrencyRate?: number;
    CurrencyUnit?: number; // default 1
    DepartmentId?: number;
    ProjectId?: number;
    InvoiceReferenceNo?: string;
    InvoiceOcr?: string;
    TaxNo?: number;
    PeriodDate?: string;
    Comment?: string;
    StampNo?: number;
    BankAccountNo?: string;
    LinkId?: string; // GUID
    Links?: string[]; // Array of LinkIds
    LineId?: string; // For linking to existing entries
}

export interface EntryItem {
    LineId: string; // GUID
    DueDate: string;
}

export interface LinkEntryItem {
    LineIds: string[]; // Array of GUIDs
    LinkId: number;
}

export interface AccountData {
    AccountId: number;
    AccountNo: number;
    AccountName: string;
    AccountTax: number;
    TaxNo: number;
}

export enum AccountDataError {
    OK = 'OK',
    AccountDontExist = 'AccountDontExist',
    NameDontMatch = 'NameDontMatch'
}

export interface TypeData {
    TypeId: number;
    TypeNo: number;
    Title: string;
    EntrySeriesID: number;
}

export interface TaxMappingList {
    GroupId: string; // GUID
    Name: string;
    Description: string;
    IsTemplate: boolean;
    ElementList: TaxMappingElement[];
}

export interface TaxMappingElement {
    Symbol: string;
    TaxNo: number;
}

export interface TaxCodeElement {
    TaxId: number;
    TaxNo: string;
    TaxName: string;
    TaxRate: number;
    AccountNo: number;
}

export enum SaveBundleListResultType {
    Ok = 'Ok',
    DuplicateData = 'DuplicateData',
    DataAlreadySaved = 'DataAlreadySaved',
    NotAuthenticated = 'NotAuthenticated',
    SystemError = 'SystemError',
    Exception = 'Exception',
    NotSaved = 'NotSaved'
}

export interface SaveBundleListResult {
    Type: SaveBundleListResultType;
    Description: string;
}

export interface GetEntryIdResult {
    Date: string;
    SortNo: number;
    EntryNo: number;
}

export interface ArgEntryId {
    Date: string;
    SortNo: number;
    EntryNo: number;
}

// Attachment Service Types
/**
 * Key-value pair for metadata
 */
export interface KeyValuePair {
    Key: string;
    Value: string;
}

/**
 * Image file in 24SevenOffice
 */
export interface ImageFile {
    Id: number;                      // Set by response from Create
    Type: FileType;                  // Enum of supported file types
    StampNo?: number;               // Read only, not used when saving
    StampMeta?: KeyValuePair[];     // Read only, not used when saving
    FrameInfo?: ImageFrameInfo[];   
    ContactId?: number[];           // Read only, lists approvers
}

export enum FileType {
    Unknown = 'Unknown',
    WMF = 'WMF',
    PNG = 'PNG',
    TIFF = 'TIFF',
    BMP = 'BMP',
    GIF = 'GIF',
    JPEG = 'JPEG'
}

/**
 * File location in 24SevenOffice.
 * - Retrieval: Image will show up in the inbox in the Retrieval Module
 * - Journal: Image is posted directly as journal data (skips inbox)
 * - Scanning: NOT IMPLEMENTED - DO NOT USE
 */
export enum FileLocation {
    Retrieval = 'Retrieval',
    Scanning = 'Scanning',  // Not implemented and may not be used
    Journal = 'Journal'
}

/**
 * Frame information for an image file.
 */
export interface ImageFrameInfo {
    Id: number;              // Must be set to 1
    Uri?: never;            // Not in use - should never be set
    StampNo: number;        // Current or new stamp number from GetStampNo
    MetaData?: KeyValuePair[];  // Changed from MetaData[] to KeyValuePair[]
    Status: number;         // Not in use - must be set to 0
}

/**
 * Metadata fields for attachment files in 24SevenOffice.
 * Note: These fields are only used when location is set to Retrieval.
 * They populate corresponding fields in the Retrieval Module.
 * Meta data is not automatically populated if you also specify a StampNo.
 */
export interface MetaDataFields {
    Amount?: string;
    Comment?: string;
    Credit?: string;
    CurrencySymbol?: string;
    CustomerName?: string;
    CustomerNo?: string;
    Debit?: string;
    Dimensions?: string;
    DocumentFormat?: string;
    InvoiceBankAccountNo?: string;
    InvoiceDate?: string;
    InvoiceDueDate?: string;
    InvoiceNo?: string;
    InvoiceOCR?: string;
    TransactionTypeNo?: string;
    Type?: string;
    PageNo?: string;
}

export interface FileInfoParameters {
    StampNo?: number[];
    FileId?: number[];
    AttachmentRegisteredAfter?: string;
    AttachmentChangedAfter?: string;
    HasStampNo?: boolean;
    FileApproved?: boolean;
    AttachmentStatus?: FlagType[];
}

export enum FlagType {
    None = 'None',
    Assigned = 'Assigned',
    Approved = 'Approved',
    Declined = 'Declined',
    Archived = 'Archived',
    Distributed = 'Distributed',
    PrepostedInJournal = 'PrepostedInJournal',
    PostedInJournal = 'PostedInJournal'
}

// Attachment Service Response Types
export interface StampSeries {
    Id: string; // guid
    Name: string;
    Start: number;
    End: number;
}

export interface GetSeriesResult {
    StampSeries: StampSeries[];
}

export interface GetFileInfoResult {
    ImageFile: ImageFile[];
}

export interface CreateResult extends ImageFile {}

================
File: packages/twentyfour/.gitignore
================
# Based on https://raw.githubusercontent.com/github/gitignore/main/Node.gitignore

# Logs

logs
_.log
npm-debug.log_
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)

report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# Runtime data

pids
_.pid
_.seed
\*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover

lib-cov

# Coverage directory used by tools like istanbul

coverage
\*.lcov

# nyc test coverage

.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)

.grunt

# Bower dependency directory (https://bower.io/)

bower_components

# node-waf configuration

.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)

build/Release

# Dependency directories

node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)

web_modules/

# TypeScript cache

\*.tsbuildinfo

# Optional npm cache directory

.npm

# Optional eslint cache

.eslintcache

# Optional stylelint cache

.stylelintcache

# Microbundle cache

.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history

.node_repl_history

# Output of 'npm pack'

\*.tgz

# Yarn Integrity file

.yarn-integrity

# dotenv environment variable files

.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)

.cache
.parcel-cache

# Next.js build output

.next
out

# Nuxt.js build / generate output

.nuxt
dist

# Gatsby files

.cache/

# Comment in the public line in if your project uses Gatsby and not Next.js

# https://nextjs.org/blog/next-9-1#public-directory-support

# public

# vuepress build output

.vuepress/dist

# vuepress v2.x temp and cache directory

.temp
.cache

# Docusaurus cache and generated files

.docusaurus

# Serverless directories

.serverless/

# FuseBox cache

.fusebox/

# DynamoDB Local files

.dynamodb/

# TernJS port file

.tern-port

# Stores VSCode versions used for testing VSCode extensions

.vscode-test

# yarn v2

.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.\*

================
File: packages/twentyfour/index.ts
================
export * from './src/types.js';
export * from './src/soapClient.js';
export * from './src/accountService.js';
export * from './src/attachmentService.js';

================
File: packages/twentyfour/package.json
================
{
  "name": "@biso/twentyfour",
  "version": "0.0.1",
  "module": "index.ts",
  "type": "module",
  "dependencies": {
    "@biso/appwrite": "0.0.1",
    "bun-types": "latest",
    "zod": "3"
  }
}

================
File: packages/twentyfour/README.md
================
# 24SevenOffice Integration Package

This package provides utilities for integrating with 24SevenOffice ERP system, handling orders, products, and customer data for BISO applications.

## 📦 Installation

```bash
bun install
# or
yarn install
```

## 🔧 Configuration

The package requires the following environment variables in the root directory:

```env
TWENTYFOUR_API_KEY=your_api_key
TWENTYFOUR_CLIENT_ID=your_client_id
TWENTYFOUR_USERNAME=your_username
TWENTYFOUR_PASSWORD=your_password
```

## 🚀 Usage

```typescript
import { createOrder, getProduct } from '@biso/twentyfour';

// Example: Create a new order
const order = await createOrder({
  customerId: 'customer_id',
  items: [
    {
      productId: 'product_id',
      quantity: 1
    }
  ]
});

// Example: Get product details
const product = await getProduct('product_id');
```

## 📚 Available Functions

### Order Management
- `createOrder()`: Create a new order in 24SevenOffice
- `getOrder()`: Retrieve order details
- `updateOrder()`: Update an existing order
- `cancelOrder()`: Cancel an order

### Product Management
- `getProduct()`: Get product details
- `listProducts()`: List all products
- `updateProduct()`: Update product information
- `searchProducts()`: Search for products

### Customer Management
- `createCustomer()`: Create a new customer
- `getCustomer()`: Get customer details
- `updateCustomer()`: Update customer information
- `searchCustomers()`: Search for customers

### Invoice Operations
- `createInvoice()`: Create a new invoice
- `getInvoice()`: Get invoice details
- `listInvoices()`: List invoices

## 🔐 Security

- Store API credentials securely
- Never commit credentials or sensitive information
- Use environment variables for all sensitive configuration
- Follow BISO's security protocols

## ⚠️ Important Notes

- Some operations require specific user permissions in 24SevenOffice
- Implement proper error handling for API responses

## 🤝 Contributing

1. Create a new branch for your feature
2. Make your changes
3. Submit a pull request with a clear description of changes

## 📞 Support

For support, please contact:

**Markus Heien**  
IT Manager, BI Student Organization  
Email: [markus@biso.no](mailto:markus@biso.no)  
Phone: +47 98471622

---

*Part of the BISO Functions Monorepo*

================
File: packages/twentyfour/tsconfig.json
================
{
  "compilerOptions": {
    "lib": [
      "ESNext"
    ],
    "module": "esnext",
    "target": "esnext",
    "moduleResolution": "nodenext",
    "strict": true,
    "downlevelIteration": true,
    "skipLibCheck": true,
    "jsx": "preserve",
    "allowSyntheticDefaultImports": true,
    "forceConsistentCasingInFileNames": true,
    "allowJs": true,
    "types": [
      "bun-types" // add Bun global
    ]
  }
}

================
File: packages/types/index.ts
================
export type Context = {
    req: any;
    res: any;
    log: (msg: any) => void;
    error: (msg: any) => void;
};

================
File: packages/types/package.json
================
{
    "name": "@biso/types",
    "version": "0.0.1",
    "module": "index.ts",
    "type": "module",
    "dependencies": {
      "@biso/appwrite": "0.0.1",
      "bun-types": "latest",
      "@vippsmobilepay/sdk": "^1.3.1",
      "zod": "3"
    }
  }

================
File: packages/utils/extract-text-from-pdf.ts
================
import { PDFExtract, PDFExtractOptions } from 'pdf.js-extract';

const pdfExtract = new PDFExtract();

const options: PDFExtractOptions = {
    lastPage: 1,
};

export async function extractTextFromPdf(pdf: string) {
    const text = await pdfExtract.extract(pdf, options);
    return text;
}

================
File: packages/utils/package.json
================
{
    "name": "@biso/utils",
    "version": "0.0.1",
    "module": "index.ts",
    "type": "module",
    "dependencies": {
      "@biso/appwrite": "0.0.1",
        "bun-types": "latest",
        "pdf.js-extract": "^0.2.1", 
        "zod": "3"
    }
  }

================
File: packages/vipps/src/index.ts
================
import { Client, EPaymentMethod, EPaymentMethodType } from "@vippsmobilepay/sdk";
import { ID } from "node-appwrite";

const merchantSerialNumber = process.env.VIPPS_MERCHANT_SERIAL_NUMBER!;
const subscriptionKey = process.env.VIPPS_SUBSCRIPTION_KEY!;
const clientId = process.env.VIPPS_CLIENT_ID!;
const clientSecret = process.env.VIPPS_CLIENT_SECRET!;

const client = Client({
    merchantSerialNumber,
    subscriptionKey,
    useTestMode: process.env.VIPPS_TEST_MODE === "true" ? true : false,
    retryRequests: false,
    pluginName: 'appwrite-plugin-vipps',
    pluginVersion: '1.0.0',
    systemName: 'appwrite-plugin-vipps',
    systemVersion: '1.0.0',
  });


export async function getAccessToken() {
  const token = await client.auth.getToken(clientId, clientSecret);
  return token;
}

export async function createCheckout({
    reference,
    amount,
    description,
    returnUrl,
}: {
    reference: string,
    amount: number,
    description: string,
    returnUrl: string,
}) {
  
    const checkout = await client.checkout.create(clientId, clientSecret, {
        merchantInfo: {
          callbackUrl: process.env.VIPPS_CALLBACK_URL!,
          returnUrl: returnUrl,
          callbackAuthorizationToken: ID.unique(),
        },
        transaction: {
        reference: reference,
          amount: {
            currency: 'NOK',
            value: amount, 
          },
          paymentDescription: description
        },
      });

      return checkout;
    }

export async function getCheckout({
    reference,
}: {
    reference: string,
}) {
  
    const checkout = await client.checkout.info(clientId, clientSecret, reference);

      return checkout;
}

export async function createPayment({
    token,
    reference,
    amount,
    description,
    returnUrl,
    membershipId,
    membershipName,
    phoneNumber,
    paymentMethod,
}: {
  token: string,
    reference: string,
    amount: number,
    description: string,
    returnUrl: string,
    membershipId: string,
    membershipName: string,
    phoneNumber: string,
    paymentMethod: EPaymentMethodType,
}) {

  const amountWithCents = amount * 100;
  
    const payment = await client.payment.create(token, {
      amount: {
        currency: "NOK",
        value: amountWithCents, // This value equals 10 NOK
      },
      paymentMethod: { type: paymentMethod },
      customer: { phoneNumber: phoneNumber },
      receipt: {
        orderLines: [
          {
            name: membershipName,
            id: membershipId,
            totalAmount: amountWithCents,
            totalAmountExcludingTax: amountWithCents,
            totalTaxAmount: 0,
            taxPercentage: 0,
          }
        ],
        bottomLine: {
          currency: "NOK",
          posId: membershipId,
          receiptNumber: ID.unique(),
      }
    },
    reference: reference,
    userFlow: "WEB_REDIRECT",
      returnUrl: returnUrl,
      paymentDescription: membershipId + " - " + description,
    });

    if (payment.ok) {
      return payment
    }

    return payment;
  }

export async function getPayment({
    reference,
    token,
}: {
    reference: string,
    token: string,
}) {
  
    const payment = await client.payment.info(token, reference);

    return payment; 

}

================
File: packages/vipps/index.ts
================
export * from './src/index.js';
export * from '@vippsmobilepay/sdk';

================
File: packages/vipps/package.json
================
{
    "name": "@biso/vipps",
    "version": "0.0.1",
    "module": "index.ts",
    "type": "module",
    "dependencies": {
      "@biso/appwrite": "0.0.1",
      "bun-types": "latest",
      "@vippsmobilepay/sdk": "^1.3.1",
      "zod": "3"
    }
  }

================
File: .gitattributes
================
# Auto detect text files and perform LF normalization
* text=auto

================
File: .gitignore
================
# Based on https://raw.githubusercontent.com/github/gitignore/main/Node.gitignore

# Logs

logs
_.log
npm-debug.log_
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)

report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# Runtime data

pids
_.pid
_.seed
\*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover

lib-cov

# Coverage directory used by tools like istanbul

coverage
\*.lcov

# nyc test coverage

.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)

.grunt

# Bower dependency directory (https://bower.io/)

bower_components

# node-waf configuration

.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)

build/Release

# Dependency directories

node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)

web_modules/

# TypeScript cache

\*.tsbuildinfo

# Optional npm cache directory

.npm

# Optional eslint cache

.eslintcache

# Optional stylelint cache

.stylelintcache

# Microbundle cache

.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history

.node_repl_history

# Output of 'npm pack'

\*.tgz

# Yarn Integrity file

.yarn-integrity

# dotenv environment variable files

.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)

.cache
.parcel-cache

# Next.js build output

.next
out

# Nuxt.js build / generate output

.nuxt
dist

# Gatsby files

.cache/

# Comment in the public line in if your project uses Gatsby and not Next.js

# https://nextjs.org/blog/next-9-1#public-directory-support

# public

# vuepress build output

.vuepress/dist

# vuepress v2.x temp and cache directory

.temp
.cache

# Docusaurus cache and generated files

.docusaurus

# Serverless directories

.serverless/

# FuseBox cache

.fusebox/

# DynamoDB Local files

.dynamodb/

# TernJS port file

.tern-port

# Stores VSCode versions used for testing VSCode extensions

.vscode-test

# yarn v2

.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.\*

================
File: package.json
================
{
  "name": "functions-monorepo",
  "private": "true",
  "type": "module",
  "workspaces": [
    "packages/*",
    "functions/*"
  ],
  "scripts": {
    "clean": "rm -rf node_modules packages/a/node_modules packages/b/node_modules bun.lockb packages/a/bun.lockb packages/b/bun.lockb"
  },
  "dependencies": {
    "@types/xml2js": "^0.4.14",
    "axios": "^1.7.9",
    "instagram-graph-api": "^7.0.0",
    "node-fetch": "^3.3.2",
    "xml2js": "^0.6.2"
  }
}

================
File: README.md
================
# Functions Monorepo

This monorepo contains a collection of serverless functions and utility packages for various services and integrations. The project is structured to handle different aspects of business operations including payment processing, social media integration, user management, and more.

## 🚀 Project Structure

```
functions-monorepo/
├── packages/           # Shared packages and utilities
│   ├── appwrite/      # Appwrite integration utilities
│   ├── instagram/     # Instagram API integration
│   ├── twentyfour/    # 24SevenOffice integration
│   ├── utils/         # Common utility functions
│   └── vipps/         # Vipps payment integration
│
└── functions/         # Serverless functions
    ├── 24so-create-order/
    ├── create-chat-group/
    ├── create-event/
    ├── create-membership-from-shop/
    ├── create-post/
    ├── create-user-doc/
    ├── election-vote/
    ├── extract-pdf/
    ├── get-instagram-posts-by-hashtag/
    ├── verify-biso-membership/
    ├── vipps-callback/
    ├── vipps-payment/
    └── webshop-product/
```

## 🛠️ Technology Stack

- **Runtime**: Node.js with TypeScript
- **Package Manager**: Bun/Yarn (Workspace enabled)
- **Key Dependencies**:
  - `axios`: HTTP client for API requests
  - `instagram-graph-api`: Instagram API integration
  - `xml2js`: XML parsing and processing
  - `node-fetch`: Fetch API implementation

## 📦 Packages

### Core Packages
- **appwrite**: Utilities for Appwrite backend integration
- **instagram**: Instagram API integration helpers
- **twentyfour**: 24SevenOffice integration utilities
- **utils**: Shared utility functions
- **vipps**: Vipps payment integration helpers

## ⚡ Functions

### Payment & Orders
- `24so-create-order`: Create orders in 24SevenOffice
- `vipps-payment`: Handle Vipps payment initiation
- `vipps-callback`: Process Vipps payment callbacks
- `webshop-product`: Manage webshop product operations

### User Management
- `create-user-doc`: User document creation
- `create-membership-from-shop`: Process membership purchases
- `verify-biso-membership`: Membership verification
- `election-vote`: Handle election voting process

### Content & Social
- `create-post`: Content post creation
- `create-event`: Event creation and management
- `get-instagram-posts-by-hashtag`: Instagram hashtag feed integration
- `create-chat-group`: Chat group creation

### Utilities
- `extract-pdf`: PDF data extraction functionality

## 🚦 Getting Started

1. **Clone the repository**
   ```bash
   git clone [repository-url]
   ```

2. **Install dependencies**
   ```bash
   bun install
   # or
   yarn install
   ```

3. **Clean installation (if needed)**
   ```bash
   yarn clean
   ```

## 🔧 Development

### Prerequisites
- Node.js (Latest LTS version recommended)
- Bun or Yarn package manager
- Required API keys and credentials for various services

### Package Management
> ⚠️ **Important**: When installing new npm packages for a specific package in the monorepo, you must run the install command from within that package's directory, not at the root level.

Example:
```bash
# Correct way
cd packages/instagram
bun add axios   # or yarn add axios

# Incorrect way
# Don't install package dependencies from root
bun add axios   # ❌
```

### Environment Setup
Each function and package may require specific environment variables. Please refer to the individual function/package documentation for detailed requirements.

## 📚 Documentation

Each package and function contains its own README with specific documentation. Common patterns and utilities are documented in the respective package directories.

### Key Integration Points
- Appwrite Backend
- Instagram Graph API
- Vipps Payment Services
- 24SevenOffice
- PDF Processing

## 🤝 Contributing

1. Create a new branch for your feature
2. Make your changes
3. Submit a pull request with a clear description of the changes

## 📝 License

This codebase is proprietary and intended for internal use only within BI Student Organization. Unauthorized distribution or modification of this code outside the company is prohibited.

For more information, please contact the IT department.

## 🔐 Security

- All API keys and sensitive credentials should be stored in environment variables
- Never commit sensitive information to the repository
- Follow security best practices when handling user data and payments

## 📞 Support
For support, please contact:

**Markus Heien**  
IT Manager, BI Student Organization  
Email: [markus@biso.no](mailto:markus@biso.no)  
Phone: +47 98471622


---

*Last updated: January 29th 2025*

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "lib": ["ESNext"],
    "module": "nodenext",
    "target": "esnext",
    "moduleResolution": "nodenext",
    "strict": true,
    "downlevelIteration": true,
    "skipLibCheck": true,
    "jsx": "preserve",
    "allowSyntheticDefaultImports": true,
    "forceConsistentCasingInFileNames": true,
    "allowJs": true,
    "types": [
      "bun-types" // add Bun global
    ]
  }
}



================================================================
End of Codebase
================================================================
